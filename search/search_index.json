{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>HestiaStore is a lightweight, embeddable key-value storage engine optimized for billions of records, designed to run in a single directory with high performance and minimal configuration.</p> <p>Features:</p> <pre><code> \u2022 Pure Java (no native dependencies), easy to embed\n \u2022 200k+ ops/s; predictable I/O with configurable buffering\n \u2022 In-memory or file-backed storage, zero-config setup\n \u2022 Pluggable filters: Snappy compression, CRC32 integrity, magic-number validation\n \u2022 Bloom filter for fast negative lookups (tunable false-positive rate)\n \u2022 Segmented SST structure with sparse index for efficient range scans\n \u2022 Custom key/value types via type descriptors\n \u2022 Single-writer, multi-reader (optional synchronized mode)\n \u2022 Test-friendly MemDirectory for fast, isolated tests\n \u2022 Roadmap: write-ahead logging and advanced compaction\n</code></pre>"},{"location":"#performance-comparison","title":"\ud83d\ude80 Performance Comparison","text":"Engine Score [ops/s] Occupied space CPU Usage ChronicleMap 5 954 20.54 GB 7% H2 13 458 8 KB 21% HestiaStoreBasic 208 723 9.71 GB 6% HestiaStoreCompress 197 335 4.97 GB 6% LevelDB 45 263 1.4 GB 17% MapDB 2 946 496 MB 14% RocksDB 305 712 7.74 GB 6% <p>Detailed methodology and full benchmark artifacts are available at benchmark results.</p>"},{"location":"#feature-comparison","title":"\ud83d\udcca Feature Comparison","text":"<p>Architecture &amp; Concurrency</p> Engine Storage/Index Concurrency Background Work HestiaStore Segmented on-disk structure Single-writer, multi-reader (optional synchronized) Periodic segment flush/merge RocksDB LSM tree (leveled/uni) Highly concurrent Compaction + flush threads LevelDB LSM tree Single-writer, multi-reader Compaction MapDB B-tree/H-tree Thread-safe (synchronized) Periodic commits ChronicleMap Off-heap mmap hash map Lock-free/low-lock None (no compaction) H2 B-tree Concurrent (MVCC) Checkpoint/auto-vacuum <p>Durability &amp; Fit</p> Engine Durability Compression Runtime Deps Typical Fit HestiaStore File-backed; commit on close Snappy Pure Java (JAR-only) Embedded KV with simple ops, large datasets RocksDB WAL + checkpoints (optional transactions) Snappy/Zstd/LZ4 Native library High write throughput, low-latency reads LevelDB File-backed; no transactions Snappy JAR-only port/native bindings Lightweight LSM, smaller footprints MapDB File-backed; optional TX None/limited Pure Java (JAR-only) Simple embedded maps/sets ChronicleMap Memory-mapped persistence; no ACID TX None Pure Java (JAR-only) Ultra-low latency shared maps H2 WAL + MVCC transactions Optional Pure Java (JAR-only) SQL + transactional workloads <p>Notes</p> <ul> <li>\u201cConcurrency\u201d describes the general access model; specifics depend on configuration and workload.</li> <li>HestiaStore focuses on predictable file I/O with configurable buffering; WAL/transactions are on the roadmap.</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Please read our Contributing Guidelines before submitting a pull request.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>HestiaStore Index architecture</li> <li>How to use HestiaStore including some examples</li> <li>Index configuration and configuration properties explaining</li> <li>Library Logging How to setup loggin</li> <li>Project versioning and how to release snapshot and new version</li> </ul>"},{"location":"#installation-and-basic-usage","title":"\ud83d\udce6 Installation and Basic Usage","text":"<p>To include HestiaStore in your Maven project, add the following dependency to your <code>pom.xml</code>:</p> <pre><code>&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.hestiastore.index&lt;/groupId&gt;\n    &lt;artifactId&gt;core&lt;/artifactId&gt;\n    &lt;version&gt;0.0.5&lt;/version&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Replace the version number with the latest available from Maven Central.</p> <p>Note: HestiaStore requires Java 17 or newer.</p> <p>You can create a new index using the builder pattern as shown below:</p> <pre><code>// Create an in-memory file system abstraction\nDirectory directory = new MemDirectory();\n\n// Prepare index configuration\nIndexConfiguration&lt;String, String&gt; conf = IndexConfiguration\n        .&lt;String, String&gt;builder()//\n        .withKeyClass(String.class)//\n        .withValueClass(String.class)//\n        .withName(\"test_index\") //\n        .build();\n\n// Create a new index\nIndex&lt;String, String&gt; index = Index.&lt;String, String&gt;create(directory, conf);\n\n// Perform basic operations\nindex.put(\"Hello\", \"World\");\n\nString value = index.get(\"Hello\");\nSystem.out.println(\"Value for 'Hello': \" + value);\n\nindex.close();\n</code></pre>"},{"location":"#roadmap","title":"\ud83d\uddfa\ufe0f Roadmap","text":"<p>Planned improvements include:</p> <ul> <li>Enhance Javadoc documentation</li> <li>Implement data consistency verification using checksums</li> <li>Complete the implementation of Write-Ahead Logging (WAH)</li> </ul> <p>For detailed tasks and progress, see the GitHub Issues page.</p>"},{"location":"#need-help-or-have-questions","title":"\u2753 Need Help or Have Questions?","text":"<p>If you encounter a bug, have a feature request, or need help using HestiaStore, please create an issue.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog.</p>"},{"location":"CHANGELOG/#005","title":"0.0.5","text":""},{"location":"CHANGELOG/#added","title":"\u2728 Added","text":"<ul> <li>Data blocks were introduced and the on-disk storage format was significantly improved.</li> <li>All disk writes now use a temporary file followed by an atomic rename; all streams are correctly closed.</li> <li>Data storage is configurable via the application configuration.</li> <li>Data in chunks and data blocks are validated using a magic number and CRC32.</li> <li>Added support for Snappy compression.</li> </ul>"},{"location":"CHANGELOG/#004","title":"0.0.4","text":""},{"location":"CHANGELOG/#added_1","title":"\u2728 Added","text":"<ul> <li>Add recovery support to rebuild indexes after failures. (#22)</li> <li>Introduce pages for segment-based indexing. (#31)</li> <li>Create <code>Directory</code> implementation using <code>java.nio</code>. (#50)</li> <li>Add a performance comparison framework for benchmark testing. (#60)</li> <li>Add integration tests for deletion and graceful degradation. (#76, #63)</li> <li>Add a test class for long-running index operations. (#49)</li> </ul>"},{"location":"CHANGELOG/#changed","title":"\ud83d\udd27 Changed","text":"<ul> <li>Improve design of the <code>sorteddatafile</code> package for better modularity. (#59)</li> <li>Enhance index configuration validation and parameter consistency. (#81)</li> <li>Introduce limits on the number of delta files to prevent unbounded growth. (#75)</li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"\ud83e\udd1d Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"\ud83c\udf1f Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others\u2019 private information, such as a physical or email address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"\ud83d\udccb Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"\ud83d\udee1\ufe0f Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team via project issue. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"\ud83d\udcce Attribution","text":"<p>This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by the Citizen Code of Conduct.</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq.</p> <p>I\u2019ll personally make every effort to answer your questions and explain anything that\u2019s unclear. We are committed to discussing any feedback or questions you may have and will explain everything in detail to ensure transparency and understanding.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to HestiaStore","text":"<p>Thank you for your interest in contributing to HestiaStore! We're excited to welcome your ideas, improvements, and bug fixes. Please follow the guidelines below to ensure a smooth and productive collaboration.</p>"},{"location":"CONTRIBUTING/#before-you-start","title":"\ud83e\udded Before You Start","text":"<p>Please make sure there is an existing issue or create a new one that describes your intended change or feature. This helps us track and discuss proposals before any code is written.</p>"},{"location":"CONTRIBUTING/#code-style","title":"\ud83e\uddd1\u200d\ud83d\udcbb Code Style","text":"<p>We follow a consistent Java coding style defined by the Eclipse formatter settings in <code>./eclipse-formatter.xml</code>. Please configure your IDE to use this formatter to keep the codebase consistent.</p>"},{"location":"CONTRIBUTING/#code-quality-checks","title":"\ud83e\uddea Code Quality Checks","text":"<p>Before submitting your code, please verify the following:</p> <ul> <li>\u2705 Run Site Checks   Execute <code>mvn clean site</code> to generate the project site and perform static analysis. This will highlight issues reported by:</li> <li>PMD</li> <li>Checkstyle</li> <li> <p>SpotBugs (formerly FindBugs)   Please ensure your changes do not introduce new warnings or violations.</p> </li> <li> <p>\u2705 Test Coverage   All new code should be covered by unit tests. We use JUnit. Run tests and verify that your code is being exercised by checking the line coverage in the site reports.</p> </li> <li> <p>\u2705 Javadoc Comments   Public methods, classes, and significant internal logic should be documented using Javadoc. Clear documentation helps others understand and maintain the project.</p> </li> </ul>"},{"location":"CONTRIBUTING/#commit-and-submit","title":"\ud83d\udee0 Commit and Submit","text":"<ol> <li>Make your changes in a separate branch.</li> <li>Push your branch to your fork or the main repo (if you have access).</li> <li>Open a Pull Request with a clear title and description.</li> <li>Link to the related issue or ticket.</li> </ol>"},{"location":"CONTRIBUTING/#review-process","title":"\u23f3 Review Process","text":"<p>Once submitted, your PR will be reviewed by a maintainer. We may request changes or ask clarifying questions. Please be patient \u2014 reviews are important to keep the project healthy.</p>"},{"location":"CONTRIBUTING/#thanks","title":"\ud83d\ude4c Thanks","text":"<p>We appreciate your contribution, whether it's code, documentation, or ideas. Your support makes HestiaStore better!</p> <p>\ud83d\udcac For questions, feel free to open a GitHub Issue.</p>"},{"location":"SECURITY/","title":"HestiaStore Security","text":"<p>Security and quality are important considerations in the HestiaStore project. While HestiaStore is a library (not a network-exposed service), several tools are in place to monitor and improve code and dependency safety.</p>"},{"location":"SECURITY/#dependency-scanning","title":"\ud83e\uddea Dependency Scanning","text":"<p>HestiaStore uses the OWASP Dependency-Check Maven plugin to automatically scan project dependencies for known vulnerabilities. The scan is performed during the Maven <code>verify</code> phase. This helps detect issues in third-party libraries such as outdated or vulnerable versions of common libraries.</p> <p>The OWASP dependency report is also included in the Maven Site documentation.</p>"},{"location":"SECURITY/#data-storage-security","title":"\ud83d\udcbe Data Storage Security","text":"<p>Currently, HestiaStore does not support a persistent, remote or encrypted storage backend. All data is stored in the local file system or memory, depending on the <code>Directory</code> implementation (e.g. <code>FsDirectory</code> or <code>MemDirectory</code>). Support for more advanced persistent stores with security features like encryption may be added in the future.</p>"},{"location":"SECURITY/#static-code-analysis","title":"\ud83d\udd75\ufe0f Static Code Analysis","text":"<p>HestiaStore uses the following tools to enforce code quality and detect potential bugs:</p> <ul> <li>PMD: Checks for common coding errors, best practices violations, and potential bugs.</li> <li>SpotBugs (formerly FindBugs): Performs bytecode-level bug detection for possible concurrency issues, null pointer dereferences, etc.</li> </ul> <p>Both reports are available through the Maven Site (<code>mvn site</code>).</p>"},{"location":"SECURITY/#testing-and-coverage","title":"\u2705 Testing and Coverage","text":"<p>The project includes a comprehensive suite of unit tests. Test coverage is measured using JaCoCo, and the coverage report is also published as part of the Maven Site.</p> <pre><code>mvn clean verify site\n</code></pre> <p>This will generate the full set of reports under <code>target/site/</code>.</p>"},{"location":"SECURITY/#threat-model","title":"\ud83d\udd10 Threat Model","text":"<p>HestiaStore is designed to run as a component within a trusted local application. It does not expose network interfaces or provide internal access control mechanisms. As such, it assumes that:</p> <ul> <li>The host operating environment is trusted.</li> <li>Filesystem access is managed by the application or OS.</li> <li>Inputs to the library are trusted or validated upstream.</li> </ul>"},{"location":"SECURITY/#known-risks","title":"\u26a0\ufe0f Known Risks","text":"Threat Mitigated? Notes Malicious input data \u274c No input sanitization is performed Unauthorized file access \u274c No access control; relies on OS permissions File corruption \ud83d\udeab Partial protection through optional WAL Memory data leakage \u274c JVM memory is not encrypted or zeroed Index inconsistency \u26a0\ufe0f Recovery possible using <code>checkAndRepairConsistency()</code>"},{"location":"SECURITY/#trust-boundaries","title":"\ud83d\udee1\ufe0f Trust Boundaries","text":"<p>HestiaStore does not define security boundaries within its API. Instead, it assumes that:</p> <ul> <li>The file system used by <code>FsDirectory</code> is controlled by the same principal as the application.</li> <li>Memory content is considered volatile and not protected against memory inspection.</li> <li>The user is responsible for isolating the library appropriately in containerized or multi-tenant environments.</li> </ul>"},{"location":"SECURITY/#data-integrity","title":"\ud83d\udd0d Data Integrity","text":"<p>HestiaStore provides limited protections:</p> <ul> <li>Optional Write-Ahead Logging (WAL) ensures durability between flushes.</li> <li>Manual compaction and <code>checkAndRepairConsistency()</code> assist in recovery from logical inconsistencies.</li> <li>No built-in checksums or MACs are currently used.</li> </ul>"},{"location":"SECURITY/#encryption","title":"\ud83d\udd12 Encryption","text":"<p>HestiaStore does not implement:</p> <ul> <li>Encryption at rest</li> <li>Encryption in memory</li> <li>Encrypted WAL or segment files</li> </ul> <p>Users requiring data confidentiality should enable full-disk encryption or isolate the storage backend appropriately.</p>"},{"location":"SECURITY/#denial-of-service-considerations","title":"\ud83c\udfd7\ufe0f Denial of Service Considerations","text":"<p>While HestiaStore is efficient, certain usage patterns may degrade system performance:</p> <ul> <li>Inserting excessive data without flushing may exhaust memory.</li> <li>Large segment files may incur slow read or compaction times.</li> <li><code>withThreadSafe(true)</code> may incur additional locking overhead under heavy concurrency.</li> </ul>"},{"location":"SECURITY/#security-responsibilities-of-integrators","title":"\ud83d\udc77 Security Responsibilities of Integrators","text":"<p>Users embedding HestiaStore must take responsibility for:</p> <ul> <li>Validating inputs</li> <li>Managing access to the directory path</li> <li>Applying memory and disk usage quotas externally</li> <li>Protecting against unauthorized runtime access</li> </ul>"},{"location":"SECURITY/#future-work","title":"\ud83d\udd27 Future Work","text":"<p>Planned or considered improvements include:</p> <ul> <li>Optional encryption of segment data</li> <li>Checksumming of stored values</li> <li>Sandboxed key/value type descriptors</li> </ul>"},{"location":"SECURITY/#summary","title":"\ud83d\udccb Summary","text":"<ul> <li>\u2705 Vulnerability scanning via OWASP Dependency Check</li> <li>\u2705 Static analysis via PMD and SpotBugs</li> <li>\u2705 Unit tests with coverage reporting via JaCoCo</li> <li>\u23f3 Persistent encrypted storage is not yet supported</li> <li>\u2705 Basic threat model documented</li> <li>\u26a0\ufe0f Assumes trusted host environment (no access control or encryption)</li> <li>\ud83d\udea7 Future improvements under consideration (checksums, encryption)</li> </ul> <p>If you encounter any problems, discover vulnerabilities, or have questions, please report them by opening an issue in the project's GitHub repository.</p>"},{"location":"alternatives/","title":"Alternatives","text":"<p>HestiaStore is one of many available solutions for key-value storage. When selecting the right tool, it's important to consider which one best fits your needs. Here are some key evaluation criteria:</p> <ul> <li>\ud83d\udd01 Transactional Support</li> <li>\ud83e\uddea ACID Compliance</li> <li>\u2601\ufe0f Cloud Availability</li> <li>\u26a1 Performance</li> <li>\ud83d\udee0\ufe0f Error Handling</li> <li>\ud83d\udcda API Completeness ...</li> </ul> <p>Below are a few notable alternatives (not an exhaustive list):</p>"},{"location":"alternatives/#mapdb","title":"\ud83d\uddfa\ufe0f MapDB","text":"<p>Homepage / GitHub</p> <p>MapDB focuses on replacing <code>java.util.Map</code> with a disk-backed map structure. While powerful, its recent versions have limited disk persistence support and performance may be slower for some use cases.</p>"},{"location":"alternatives/#h2-mvstore","title":"\ud83d\uddc3\ufe0f H2 MVStore","text":"<p>Homepage</p> <p>MVStore is the underlying storage engine for the H2 database. It features a friendly API, support for transactions, and generally good performance. It is well-suited for embedded systems and relational data scenarios.</p>"},{"location":"alternatives/#chronicle-map","title":"\ud83d\udcd8 Chronicle Map","text":"<p>Homepage</p> <p>Chronicle Map offers low-latency, off-heap key-value storage with support for huge datasets. It is especially suitable for high-performance and low-GC scenarios. Disk persistence is supported, though the primary target is memory-mapped data sharing.</p>"},{"location":"alternatives/#rocksdb","title":"\ud83e\udea8 RocksDB","text":"<p>Homepage / GitHub</p> <p>RocksDB is a mature, high-performance embedded key-value store developed by Facebook. While it is written in C++, a Java binding is available. It supports compression, compaction, snapshots, and many tuning options.</p>"},{"location":"alternatives/#babudb","title":"\ud83d\udc18 BabuDB","text":"<p>Homepage</p> <p>BabuDB is a log-structured, non-relational key-value store optimized for write performance and reliability. It's less widely used today but offers interesting architectural choices like write-ahead logging and on-disk persistence.</p>"},{"location":"benchmark-results/","title":"HestiaStore Benchmark Results","text":""},{"location":"benchmark-results/#test-conditions","title":"Test Conditions","text":"<ul> <li>Every benchmark in the plain-load suite runs inside the same controlled JVM environment with identical JVM flags and hardware resources. Runs start by wiping the working directory supplied through the <code>dir</code> system property, so each trial writes into a fresh, empty location.</li> <li>Execution stays single-threaded from warm-up through measurement. The test focuses purely on how quickly one writer can push key/value pairs into the storage engine without any coordination overhead from additional threads.</li> <li>Warm-up phases fill the database as aggressively as possible for several 20-second stretches. This stage is meant to trigger JIT compilation, populate caches, and let LevelDB settle into steady-state behaviour before any numbers are recorded.</li> <li>Measurement phases repeat the same single-threaded write loop. Throughput is observed over multiple 20-second intervals to capture stable, sustained insert performance rather than a burst.</li> <li>Each write operation uses a deterministic pseudo-random long (seed <code>324432L</code>) to generate a unique hash string via <code>HashDataProvider</code>. The payload is the constant text <code>\"opice skace po stromech\"</code>, so variability comes exclusively from the changing keys.</li> <li>After measurements complete, the map is closed and the directory remains available for inspection. The log records how many keys were created, providing a quick sanity check that the run processed the expected volume.</li> <li>Test was performed at Mac mini 2024, 16 GB, macOS 15.6.1 (24G90).</li> </ul>"},{"location":"benchmark-results/#benchmark-results","title":"Benchmark Results","text":"Engine Score [ops/s] ScoreError Confidence Interval [ops/s] Occupied space CPU Usage ChronicleMap 5 954 1 765 4 189 .. 7 719 20.54 GB 7% H2 13 458 5 144 8 314 .. 18 601 8 KB 21% HestiaStoreBasic 208 723 123 398 85 325 .. 332 122 9.71 GB 6% HestiaStoreCompress 197 335 110 268 87 068 .. 307 603 4.97 GB 6% LevelDB 45 263 10 913 34 350 .. 56 176 1.4 GB 17% MapDB 2 946 326 2 620 .. 3 272 496 MB 14% RocksDB 305 712 78 929 226 783 .. 384 641 7.74 GB 6% <p>meaning of columns:</p> <ul> <li>Engine: name of the benchmarked engine (as derived from the JSON filename)</li> <li>Score [ops/s]: number of operations per second (higher is better)</li> <li>ScoreError: error margin of the score (lower is better). It's computed as <code>z * (stdev / sqrt(n)) where</code></li> <li><code>z</code> is the z-score for the desired confidence level (1.96 for 95%)</li> <li><code>stdev</code> is the standard deviation of the measurements</li> <li><code>n</code> is the number of measurements</li> <li>Confidence Interval: 95% confidence interval of the score (lower and upper bound). This means that the true mean is likely between this interval of ops/sec. Negative values are possible if the error margin is larger than the score itself.</li> <li>Occupied space : amount of disk space occupied by the engine's data structures (lower is better). It is measured after flushing last data to disk.</li> <li>CPU Usage: average CPU usage during the benchmark (lower is better). Please note, that it includes all system processes, not only the benchmarked engine.</li> </ul>"},{"location":"benchmark-results/#raw-json-files","title":"Raw JSON Files","text":""},{"location":"benchmark-results/#results-chroniclemap-myjson","title":"results-ChronicleMap-my.json","text":"<pre><code>{\n  \"totalDirectorySize\" : 22049472512,\n  \"fileCount\" : 1,\n  \"usedMemoryBytes\" : 27947104,\n  \"cpuBefore\" : 603274000,\n  \"cpuAfter\" : 1097938000,\n  \"startTime\" : 261108533575583,\n  \"endTime\" : 261814614016416,\n  \"cpuUsage\" : 0.07005774008077877\n}\n</code></pre>"},{"location":"benchmark-results/#results-chroniclemapjson","title":"results-ChronicleMap.json","text":"<pre><code>[\n    {\n        \"jmhVersion\" : \"1.37\",\n        \"benchmark\" : \"org.hestiastore.index.benchmark.plainload.TestChronicleMap.write\",\n        \"mode\" : \"thrpt\",\n        \"threads\" : 1,\n        \"forks\" : 1,\n        \"jvm\" : \"/opt/homebrew/Cellar/openjdk@21/21.0.7/libexec/openjdk.jdk/Contents/Home/bin/java\",\n        \"jvmArgs\" : [\n            \"-Xmx10000m\",\n            \"--add-opens=java.base/java.lang=ALL-UNNAMED\",\n            \"--add-opens=java.base/java.lang.reflect=ALL-UNNAMED\",\n            \"--add-opens=java.base/java.io=ALL-UNNAMED\",\n            \"--add-opens=java.base/java.nio=ALL-UNNAMED\",\n            \"--add-opens=java.base/sun.nio.ch=ALL-UNNAMED\",\n            \"--add-opens=jdk.compiler/com.sun.tools.javac=ALL-UNNAMED\",\n            \"--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED\",\n            \"--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED\",\n            \"--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED\",\n            \"--add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED\",\n            \"--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED\",\n            \"--add-opens=jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED\",\n            \"--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED\",\n            \"--add-opens=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED\",\n            \"--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED\",\n            \"-Ddir=/Volumes/ponrava/test-index\",\n            \"-Dengine=ChronicleMap\"\n        ],\n        \"jdkVersion\" : \"21.0.7\",\n        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n        \"vmVersion\" : \"21.0.7\",\n        \"warmupIterations\" : 10,\n        \"warmupTime\" : \"20 s\",\n        \"warmupBatchSize\" : 1,\n        \"measurementIterations\" : 25,\n        \"measurementTime\" : \"20 s\",\n        \"measurementBatchSize\" : 1,\n        \"primaryMetric\" : {\n            \"score\" : 5954.200373600311,\n            \"scoreError\" : 1764.90521298729,\n            \"scoreConfidence\" : [\n                4189.295160613021,\n                7719.105586587601\n            ],\n            \"scorePercentiles\" : {\n                \"0.0\" : 3329.640674916557,\n                \"50.0\" : 5243.630014833653,\n                \"90.0\" : 10595.405308112338,\n                \"95.0\" : 12253.872048619854,\n                \"99.0\" : 12744.707905617659,\n                \"99.9\" : 12744.707905617659,\n                \"99.99\" : 12744.707905617659,\n                \"99.999\" : 12744.707905617659,\n                \"99.9999\" : 12744.707905617659,\n                \"100.0\" : 12744.707905617659\n            },\n            \"scoreUnit\" : \"ops/s\",\n            \"rawData\" : [\n                [\n                    11108.58838229165,\n                    12744.707905617659,\n                    10253.283258659461,\n                    7641.776148398347,\n                    7065.625130993228,\n                    6245.862123216896,\n                    5726.337056869982,\n                    5546.963290190697,\n                    5312.460633150494,\n                    5243.630014833653,\n                    5127.273627636177,\n                    4443.333421250085,\n                    4570.51338982323,\n                    4905.02077335985,\n                    5196.530108141268,\n                    3329.640674916557,\n                    3829.198465291546,\n                    7600.50765102385,\n                    6131.287347339458,\n                    5543.996756565399,\n                    4995.077322180827,\n                    4772.012372724426,\n                    3916.673020709464,\n                    3514.748215845972,\n                    4089.96224897762\n                ]\n            ]\n        },\n        \"secondaryMetrics\" : {\n        }\n    }\n]\n</code></pre>"},{"location":"benchmark-results/#results-h2-myjson","title":"results-H2-my.json","text":"<pre><code>{\n  \"totalDirectorySize\" : 8192,\n  \"fileCount\" : 1,\n  \"usedMemoryBytes\" : 27133320,\n  \"cpuBefore\" : 1035200000,\n  \"cpuAfter\" : 2479448000,\n  \"startTime\" : 258786636432958,\n  \"endTime\" : 259488720650875,\n  \"cpuUsage\" : 0.2057086547657931\n}\n</code></pre>"},{"location":"benchmark-results/#results-h2json","title":"results-H2.json","text":"<pre><code>[\n    {\n        \"jmhVersion\" : \"1.37\",\n        \"benchmark\" : \"org.hestiastore.index.benchmark.plainload.TestH2.write\",\n        \"mode\" : \"thrpt\",\n        \"threads\" : 1,\n        \"forks\" : 1,\n        \"jvm\" : \"/opt/homebrew/Cellar/openjdk@21/21.0.7/libexec/openjdk.jdk/Contents/Home/bin/java\",\n        \"jvmArgs\" : [\n            \"-Xmx10000m\",\n            \"-Ddir=/Volumes/ponrava/test-index\",\n            \"-Dengine=H2\"\n        ],\n        \"jdkVersion\" : \"21.0.7\",\n        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n        \"vmVersion\" : \"21.0.7\",\n        \"warmupIterations\" : 10,\n        \"warmupTime\" : \"20 s\",\n        \"warmupBatchSize\" : 1,\n        \"measurementIterations\" : 25,\n        \"measurementTime\" : \"20 s\",\n        \"measurementBatchSize\" : 1,\n        \"primaryMetric\" : {\n            \"score\" : 13457.521378452284,\n            \"scoreError\" : 5143.803121401257,\n            \"scoreConfidence\" : [\n                8313.718257051027,\n                18601.32449985354\n            ],\n            \"scorePercentiles\" : {\n                \"0.0\" : 4492.791786534924,\n                \"50.0\" : 13209.02178518997,\n                \"90.0\" : 21853.77922605105,\n                \"95.0\" : 29631.650534341064,\n                \"99.0\" : 32749.29402436372,\n                \"99.9\" : 32749.29402436372,\n                \"99.99\" : 32749.29402436372,\n                \"99.999\" : 32749.29402436372,\n                \"99.9999\" : 32749.29402436372,\n                \"100.0\" : 32749.29402436372\n            },\n            \"scoreUnit\" : \"ops/s\",\n            \"rawData\" : [\n                [\n                    12623.654285480005,\n                    11839.343622462286,\n                    14436.728477425342,\n                    13633.043439408131,\n                    16157.467112454447,\n                    6412.401044547184,\n                    6265.687494095522,\n                    18612.922946912684,\n                    16219.969068239285,\n                    12831.893972457165,\n                    18859.80952879762,\n                    4813.230127324451,\n                    13209.02178518997,\n                    22357.14905762156,\n                    18073.648245485118,\n                    8538.249998991463,\n                    32749.29402436372,\n                    18767.680908037615,\n                    21518.199338337377,\n                    8642.521511716302,\n                    17435.121051959966,\n                    7154.46408403396,\n                    4670.397715531453,\n                    4492.791786534924,\n                    6123.3438338994565\n                ]\n            ]\n        },\n        \"secondaryMetrics\" : {\n        }\n    }\n]\n</code></pre>"},{"location":"benchmark-results/#results-hestiastorebasic-myjson","title":"results-HestiaStoreBasic-my.json","text":"<pre><code>{\n  \"totalDirectorySize\" : 10421104485,\n  \"fileCount\" : 202,\n  \"usedMemoryBytes\" : 29532080,\n  \"cpuBefore\" : 630093000,\n  \"cpuAfter\" : 1321420000,\n  \"startTime\" : 251981038188791,\n  \"endTime\" : 253079760397708,\n  \"cpuUsage\" : 0.06292099990237153\n}\n</code></pre>"},{"location":"benchmark-results/#results-hestiastorebasicjson","title":"results-HestiaStoreBasic.json","text":"<pre><code>[\n    {\n        \"jmhVersion\" : \"1.37\",\n        \"benchmark\" : \"org.hestiastore.index.benchmark.plainload.TestHestiaStoreBasic.write\",\n        \"mode\" : \"thrpt\",\n        \"threads\" : 1,\n        \"forks\" : 1,\n        \"jvm\" : \"/opt/homebrew/Cellar/openjdk@21/21.0.7/libexec/openjdk.jdk/Contents/Home/bin/java\",\n        \"jvmArgs\" : [\n            \"-Ddir=/Volumes/ponrava/test-index\",\n            \"-Dengine=HestiaStoreBasic\"\n        ],\n        \"jdkVersion\" : \"21.0.7\",\n        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n        \"vmVersion\" : \"21.0.7\",\n        \"warmupIterations\" : 10,\n        \"warmupTime\" : \"20 s\",\n        \"warmupBatchSize\" : 1,\n        \"measurementIterations\" : 25,\n        \"measurementTime\" : \"20 s\",\n        \"measurementBatchSize\" : 1,\n        \"primaryMetric\" : {\n            \"score\" : 208723.46372734453,\n            \"scoreError\" : 123398.4009790847,\n            \"scoreConfidence\" : [\n                85325.06274825982,\n                332121.86470642925\n            ],\n            \"scorePercentiles\" : {\n                \"0.0\" : 554.7618862826042,\n                \"50.0\" : 162041.0809319436,\n                \"90.0\" : 470075.70756668044,\n                \"95.0\" : 492127.1980588706,\n                \"99.0\" : 499252.60276788153,\n                \"99.9\" : 499252.60276788153,\n                \"99.99\" : 499252.60276788153,\n                \"99.999\" : 499252.60276788153,\n                \"99.9999\" : 499252.60276788153,\n                \"100.0\" : 499252.60276788153\n            },\n            \"scoreUnit\" : \"ops/s\",\n            \"rawData\" : [\n                [\n                    192122.76396490858,\n                    176314.5105152991,\n                    172106.25195735498,\n                    162041.0809319436,\n                    132489.04192779973,\n                    107779.73836212876,\n                    499252.60276788153,\n                    554.7618862826042,\n                    475501.2537378453,\n                    17154.979375749186,\n                    466458.67678590387,\n                    21687.044020994686,\n                    405378.4078260152,\n                    56166.83893309033,\n                    403344.39251664525,\n                    51301.04051122623,\n                    352834.9371019776,\n                    74215.05428872978,\n                    301901.0548791414,\n                    90049.73992580615,\n                    142494.71288749005,\n                    52679.915185932994,\n                    393918.62679864746,\n                    88953.57519155115,\n                    381385.5909032691\n                ]\n            ]\n        },\n        \"secondaryMetrics\" : {\n        }\n    }\n]\n</code></pre>"},{"location":"benchmark-results/#results-hestiastorecompress-myjson","title":"results-HestiaStoreCompress-my.json","text":"<pre><code>{\n  \"totalDirectorySize\" : 5333604997,\n  \"fileCount\" : 138,\n  \"usedMemoryBytes\" : 29625800,\n  \"cpuBefore\" : 588216000,\n  \"cpuAfter\" : 1276584000,\n  \"startTime\" : 253080135943875,\n  \"endTime\" : 254157304657416,\n  \"cpuUsage\" : 0.06390530947906137\n}\n</code></pre>"},{"location":"benchmark-results/#results-hestiastorecompressjson","title":"results-HestiaStoreCompress.json","text":"<pre><code>[\n    {\n        \"jmhVersion\" : \"1.37\",\n        \"benchmark\" : \"org.hestiastore.index.benchmark.plainload.TestHestiaStoreCompress.write\",\n        \"mode\" : \"thrpt\",\n        \"threads\" : 1,\n        \"forks\" : 1,\n        \"jvm\" : \"/opt/homebrew/Cellar/openjdk@21/21.0.7/libexec/openjdk.jdk/Contents/Home/bin/java\",\n        \"jvmArgs\" : [\n            \"-Ddir=/Volumes/ponrava/test-index\",\n            \"-Dengine=HestiaStoreCompress\"\n        ],\n        \"jdkVersion\" : \"21.0.7\",\n        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n        \"vmVersion\" : \"21.0.7\",\n        \"warmupIterations\" : 10,\n        \"warmupTime\" : \"20 s\",\n        \"warmupBatchSize\" : 1,\n        \"measurementIterations\" : 25,\n        \"measurementTime\" : \"20 s\",\n        \"measurementBatchSize\" : 1,\n        \"primaryMetric\" : {\n            \"score\" : 197335.45368451648,\n            \"scoreError\" : 110267.72261413459,\n            \"scoreConfidence\" : [\n                87067.7310703819,\n                307603.1762986511\n            ],\n            \"scorePercentiles\" : {\n                \"0.0\" : 19837.659319775263,\n                \"50.0\" : 159121.5187040372,\n                \"90.0\" : 446727.6608323127,\n                \"95.0\" : 471450.60560908867,\n                \"99.0\" : 471589.3418364573,\n                \"99.9\" : 471589.3418364573,\n                \"99.99\" : 471589.3418364573,\n                \"99.999\" : 471589.3418364573,\n                \"99.9999\" : 471589.3418364573,\n                \"100.0\" : 471589.3418364573\n            },\n            \"scoreUnit\" : \"ops/s\",\n            \"rawData\" : [\n                [\n                    189366.44800340827,\n                    182001.5193574798,\n                    170531.69717638704,\n                    162364.86104533979,\n                    159121.5187040372,\n                    125406.93654261202,\n                    106902.16819859736,\n                    471589.3418364573,\n                    20815.987134208288,\n                    471126.8877452286,\n                    19837.659319775263,\n                    430461.50955703534,\n                    41763.59810876514,\n                    373047.7099334711,\n                    70686.69226237234,\n                    352984.1656029356,\n                    76161.28448556861,\n                    331142.4783053942,\n                    83170.7709646383,\n                    300736.0137753263,\n                    91106.90765487481,\n                    153934.20182376896,\n                    59495.64115310968,\n                    398898.761738379,\n                    90731.58168374155\n                ]\n            ]\n        },\n        \"secondaryMetrics\" : {\n        }\n    }\n]\n</code></pre>"},{"location":"benchmark-results/#results-leveldb-myjson","title":"results-LevelDB-my.json","text":"<pre><code>{\n    \"totalDirectorySize\": 1508330468,\n    \"fileCount\": 754,\n    \"usedMemoryBytes\": 27954256,\n    \"cpuBefore\": 1001444000,\n    \"cpuAfter\": 2178345000,\n    \"startTime\": 260193098308000,\n    \"endTime\": 260895356813250,\n    \"cpuUsage\": 0.1675880023099229\n}\n</code></pre>"},{"location":"benchmark-results/#results-leveldbjson","title":"results-LevelDB.json","text":"<pre><code>[\n    {\n        \"jmhVersion\" : \"1.37\",\n        \"benchmark\" : \"org.hestiastore.index.benchmark.plainload.TestLevelDB.write\",\n        \"mode\" : \"thrpt\",\n        \"threads\" : 1,\n        \"forks\" : 1,\n        \"jvm\" : \"/opt/homebrew/Cellar/openjdk@21/21.0.7/libexec/openjdk.jdk/Contents/Home/bin/java\",\n        \"jvmArgs\" : [\n            \"-Xmx10000m\",\n            \"-Ddir=/Volumes/ponrava/test-index\",\n            \"-Dengine=LevelDB\"\n        ],\n        \"jdkVersion\" : \"21.0.7\",\n        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n        \"vmVersion\" : \"21.0.7\",\n        \"warmupIterations\" : 10,\n        \"warmupTime\" : \"20 s\",\n        \"warmupBatchSize\" : 1,\n        \"measurementIterations\" : 25,\n        \"measurementTime\" : \"20 s\",\n        \"measurementBatchSize\" : 1,\n        \"primaryMetric\" : {\n            \"score\" : 45262.57575204393,\n            \"scoreError\" : 10913.06838787145,\n            \"scoreConfidence\" : [\n                34349.50736417248,\n                56175.64413991538\n            ],\n            \"scorePercentiles\" : {\n                \"0.0\" : 29965.68796327744,\n                \"50.0\" : 44015.87124729542,\n                \"90.0\" : 59895.29706634639,\n                \"95.0\" : 73862.46532443774,\n                \"99.0\" : 79758.10180257274,\n                \"99.9\" : 79758.10180257274,\n                \"99.99\" : 79758.10180257274,\n                \"99.999\" : 79758.10180257274,\n                \"99.9999\" : 79758.10180257274,\n                \"100.0\" : 79758.10180257274\n            },\n            \"scoreUnit\" : \"ops/s\",\n            \"rawData\" : [\n                [\n                    79758.10180257274,\n                    39978.85200469439,\n                    59754.841638050995,\n                    30051.495747236888,\n                    59710.167696545956,\n                    30759.864807986865,\n                    59261.071048612,\n                    30156.92824167015,\n                    45828.62436018362,\n                    44015.87124729542,\n                    30051.946454605757,\n                    42438.257643466684,\n                    47017.87854596809,\n                    30308.896587398805,\n                    59599.16125957037,\n                    29965.68796327744,\n                    30159.1527061617,\n                    59564.58477647708,\n                    30361.845682382078,\n                    30347.55964289471,\n                    59253.07772711731,\n                    32183.0951788089,\n                    57862.32461600187,\n                    60105.98020878948,\n                    53069.126213328724\n                ]\n            ]\n        },\n        \"secondaryMetrics\" : {\n        }\n    }\n]\n</code></pre>"},{"location":"benchmark-results/#results-mapdb-myjson","title":"results-MapDB-my.json","text":"<pre><code>{\n  \"totalDirectorySize\" : 520093696,\n  \"fileCount\" : 1,\n  \"usedMemoryBytes\" : 27726856,\n  \"cpuBefore\" : 1110727000,\n  \"cpuAfter\" : 2088963000,\n  \"startTime\" : 259489732026041,\n  \"endTime\" : 260192350201750,\n  \"cpuUsage\" : 0.13922725511802747\n}\n</code></pre>"},{"location":"benchmark-results/#results-mapdbjson","title":"results-MapDB.json","text":"<pre><code>[\n    {\n        \"jmhVersion\" : \"1.37\",\n        \"benchmark\" : \"org.hestiastore.index.benchmark.plainload.TestMapDB.write\",\n        \"mode\" : \"thrpt\",\n        \"threads\" : 1,\n        \"forks\" : 1,\n        \"jvm\" : \"/opt/homebrew/Cellar/openjdk@21/21.0.7/libexec/openjdk.jdk/Contents/Home/bin/java\",\n        \"jvmArgs\" : [\n            \"-Xmx10000m\",\n            \"-Ddir=/Volumes/ponrava/test-index\",\n            \"-Dengine=MapDB\"\n        ],\n        \"jdkVersion\" : \"21.0.7\",\n        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n        \"vmVersion\" : \"21.0.7\",\n        \"warmupIterations\" : 10,\n        \"warmupTime\" : \"20 s\",\n        \"warmupBatchSize\" : 1,\n        \"measurementIterations\" : 25,\n        \"measurementTime\" : \"20 s\",\n        \"measurementBatchSize\" : 1,\n        \"primaryMetric\" : {\n            \"score\" : 2945.9818242698652,\n            \"scoreError\" : 325.59501594188,\n            \"scoreConfidence\" : [\n                2620.3868083279854,\n                3271.576840211745\n            ],\n            \"scorePercentiles\" : {\n                \"0.0\" : 2272.884921159144,\n                \"50.0\" : 2903.932835903283,\n                \"90.0\" : 3477.3894675973625,\n                \"95.0\" : 3980.5774803791674,\n                \"99.0\" : 4191.114455891415,\n                \"99.9\" : 4191.114455891415,\n                \"99.99\" : 4191.114455891415,\n                \"99.999\" : 4191.114455891415,\n                \"99.9999\" : 4191.114455891415,\n                \"100.0\" : 4191.114455891415\n            },\n            \"scoreUnit\" : \"ops/s\",\n            \"rawData\" : [\n                [\n                    3355.129200069919,\n                    4191.114455891415,\n                    3489.3245375172587,\n                    2438.7143275091894,\n                    2579.0322123944043,\n                    3197.038563619707,\n                    3107.3043335466377,\n                    3384.5420569152025,\n                    3026.214223864194,\n                    2955.4727465665437,\n                    2938.449490331077,\n                    2444.3275358242336,\n                    2447.5359296109964,\n                    2572.5750258119742,\n                    2629.0978967032243,\n                    2641.6700332863193,\n                    2903.932835903283,\n                    2821.317530851881,\n                    2272.884921159144,\n                    2668.589365207391,\n                    3178.0194113129796,\n                    3265.484517502896,\n                    3469.4327543174313,\n                    2897.2634039647874,\n                    2775.078297064553\n                ]\n            ]\n        },\n        \"secondaryMetrics\" : {\n        }\n    }\n]\n</code></pre>"},{"location":"benchmark-results/#results-rocksdb-myjson","title":"results-RocksDB-my.json","text":"<pre><code>{\n  \"totalDirectorySize\" : 8306458361,\n  \"fileCount\" : 143,\n  \"usedMemoryBytes\" : 29881472,\n  \"cpuBefore\" : 524178000,\n  \"cpuAfter\" : 978766000,\n  \"startTime\" : 256399236974125,\n  \"endTime\" : 257100509331250,\n  \"cpuUsage\" : 0.0648233165590143\n}\n</code></pre>"},{"location":"benchmark-results/#results-rocksdbjson","title":"results-RocksDB.json","text":"<pre><code>[\n    {\n        \"jmhVersion\" : \"1.37\",\n        \"benchmark\" : \"org.hestiastore.index.benchmark.plainload.TestRocksDB.write\",\n        \"mode\" : \"thrpt\",\n        \"threads\" : 1,\n        \"forks\" : 1,\n        \"jvm\" : \"/opt/homebrew/Cellar/openjdk@21/21.0.7/libexec/openjdk.jdk/Contents/Home/bin/java\",\n        \"jvmArgs\" : [\n            \"-Ddir=/Volumes/ponrava/test-index\",\n            \"-Dengine=RocksDB\"\n        ],\n        \"jdkVersion\" : \"21.0.7\",\n        \"vmName\" : \"OpenJDK 64-Bit Server VM\",\n        \"vmVersion\" : \"21.0.7\",\n        \"warmupIterations\" : 10,\n        \"warmupTime\" : \"20 s\",\n        \"warmupBatchSize\" : 1,\n        \"measurementIterations\" : 25,\n        \"measurementTime\" : \"20 s\",\n        \"measurementBatchSize\" : 1,\n        \"primaryMetric\" : {\n            \"score\" : 305711.8304543295,\n            \"scoreError\" : 78928.99893168075,\n            \"scoreConfidence\" : [\n                226782.83152264875,\n                384640.82938601024\n            ],\n            \"scorePercentiles\" : {\n                \"0.0\" : 64828.117457250206,\n                \"50.0\" : 303051.53710396215,\n                \"90.0\" : 440196.02218382317,\n                \"95.0\" : 451632.3622033773,\n                \"99.0\" : 452870.0724388766,\n                \"99.9\" : 452870.0724388766,\n                \"99.99\" : 452870.0724388766,\n                \"99.999\" : 452870.0724388766,\n                \"99.9999\" : 452870.0724388766,\n                \"100.0\" : 452870.0724388766\n            },\n            \"scoreUnit\" : \"ops/s\",\n            \"rawData\" : [\n                [\n                    452870.0724388766,\n                    403842.93155871733,\n                    294725.1949589473,\n                    344879.7186297531,\n                    252451.31054124268,\n                    270367.7563971078,\n                    265577.0790884009,\n                    211979.36739862378,\n                    70666.26824904919,\n                    414677.1507219246,\n                    64828.117457250206,\n                    405398.2212372984,\n                    386439.0605128443,\n                    419727.7994319734,\n                    434497.12253711926,\n                    448744.3716538789,\n                    235897.63938900485,\n                    297712.0697930812,\n                    303794.303173526,\n                    360040.8711513881,\n                    257499.74121652535,\n                    303051.53710396215,\n                    185201.4305266164,\n                    303600.34376763576,\n                    254326.28242349048\n                ]\n            ]\n        },\n        \"secondaryMetrics\" : {\n        }\n    }\n]\n</code></pre>"},{"location":"profiler-stacktrace/","title":"JVM profiler results (YourKit)","text":"<p>This page summarizes a profiling session focused on read and write performance. The goal was to identify where CPU time is spent and highlight concrete improvements.</p> <p>The workload: a separate generator produced roughly 100,000,000 key\u2013value pairs and then executed read-heavy operations against HestiaStore 0.0.5 while YourKit captured CPU samples.</p> <p>Test environment: run on a Mac mini on 24.10.2025.</p> <p></p>"},{"location":"profiler-stacktrace/#how-to-read-the-numbers","title":"\ud83e\udded How to read the numbers","text":"<p>Percentages shown below approximate the share of total CPU time across the whole run spent in each operation/stack. For example, \u201c40% byte array manipulations\u201d means about 40% of all CPU cycles were consumed in copying/transforming byte arrays end-to-end.</p>"},{"location":"profiler-stacktrace/#key-findings-high-level","title":"\ud83d\udcc8 Key findings (high level)","text":"<ul> <li>~40% in byte array manipulation (ultimately <code>System.arraycopy</code>) across several layers while moving data between buffers and chunks.</li> <li>~21% in sequential reads through stacked streams and iterators, indicating many small reads and buffer boundaries.</li> <li>~18% during stream/channel closing (clean-up cascades), suggesting repeated finalization work per access.</li> <li>~3% in file open syscalls while creating new channels for short-lived reads.</li> </ul> <p>These four areas dominate the observed CPU budget for the scenario above.</p>"},{"location":"profiler-stacktrace/#detailed-stacks-and-context","title":"\ud83e\uddf5 Detailed stacks and context","text":""},{"location":"profiler-stacktrace/#40-byte-array-manipulation","title":"~40%: byte array manipulation","text":"<p>The hot paths converge on <code>System.arraycopy</code>, coming from multiple places in the chunk/data-block pipeline. This usually indicates extra copying between intermediate buffers.</p>"},{"location":"profiler-stacktrace/#3-file-open-overhead","title":"~3%: file open overhead","text":"<p>Opening files repeatedly costs ~3% CPU. Consider reusing channels across related reads to reduce syscalls and JNI transitions.</p> <pre><code>sun.nio.fs.UnixNativeDispatcher.open0(Native Method)\nsun.nio.fs.UnixNativeDispatcher.open(UnixNativeDispatcher.java:72)\nsun.nio.fs.UnixChannelFactory.open(UnixChannelFactory.java:258)\nsun.nio.fs.UnixChannelFactory.newFileChannel(UnixChannelFactory.java:133)\nsun.nio.fs.UnixChannelFactory.newFileChannel(UnixChannelFactory.java:146)\nsun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:259)\njava.nio.file.Files.newByteChannel(Files.java:380)\njava.nio.file.Files.newByteChannel(Files.java:432)\njava.nio.file.spi.FileSystemProvider.newInputStream(FileSystemProvider.java:420)\njava.nio.file.Files.newInputStream(Files.java:160)\norg.hestiastore.index.directory.FsFileReaderStream.&lt;init&gt;(FsFileReaderStream.java:22)\norg.hestiastore.index.directory.FsDirectory.getFileReader(FsDirectory.java:29)\norg.hestiastore.index.datablockfile.DataBlockFile.getFileReader(DataBlockFile.java:69)\norg.hestiastore.index.datablockfile.DataBlockFile.openReader(DataBlockFile.java:61)\norg.hestiastore.index.chunkstore.ChunkStoreFile.openReader(ChunkStoreFile.java:52)\norg.hestiastore.index.chunkpairfile.ChunkPairFile.openIteratorAtPosition(ChunkPairFile.java:42)\norg.hestiastore.index.segment.SegmentIndexSearcher.search(SegmentIndexSearcher.java:43)\norg.hestiastore.index.segment.SegmentSearcher.get(SegmentSearcher.java:62)\norg.hestiastore.index.segment.SegmentImpl.get(SegmentImpl.java:166)\norg.hestiastore.index.sst.SstIndexImpl.get(SstIndexImpl.java:163)\norg.hestiastore.index.sst.IndexContextLoggingAdapter.get(IndexContextLoggingAdapter.java:46)\ncom.coroptis.counting.CommandCount.lambda$countBoard$0(CommandCount.java:102)\ncom.coroptis.counting.CommandCount$$Lambda.0x000000080023f0b0.accept()\njava.util.ArrayList.forEach(ArrayList.java:1596)\ncom.coroptis.counting.CommandCount.countBoard(CommandCount.java:99)\ncom.coroptis.counting.CommandCount.lambda$computeNewStates$0(CommandCount.java:82)\ncom.coroptis.counting.CommandCount$$Lambda.0x000000080023e3c0.accept()\njava.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\njava.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\norg.hestiastore.index.sst.PairIteratorToSpliterator.tryAdvance(PairIteratorToSpliterator.java:31)\njava.util.Spliterator.forEachRemaining(Spliterator.java:332)\njava.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\njava.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\njava.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\njava.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\njava.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\njava.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)\ncom.coroptis.counting.CommandCount.computeNewStates(CommandCount.java:81)\ncom.coroptis.counting.CommandCount.countRound(CommandCount.java:48)\ncom.coroptis.counting.Main.main(Main.java:132)\n</code></pre>"},{"location":"profiler-stacktrace/#21-sequential-reads-through-layered-streams","title":"~21%: sequential reads through layered streams","text":"<p>Reading through <code>BufferedInputStream</code> and custom readers accumulates overhead from many small reads and object boundaries.</p> <pre><code>sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java)\nsun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:103)\njava.io.BufferedInputStream.read1(BufferedInputStream.java:345)\njava.io.BufferedInputStream.implRead(BufferedInputStream.java:420)\njava.io.BufferedInputStream.read(BufferedInputStream.java:399)\njava.io.FilterInputStream.read(FilterInputStream.java:95)\norg.hestiastore.index.directory.FsFileReaderStream.read(FsFileReaderStream.java:51)\norg.hestiastore.index.datablockfile.DataBlockReaderImpl.read(DataBlockReaderImpl.java:35)\norg.hestiastore.index.datablockfile.DataBlockReaderImpl.read(DataBlockReaderImpl.java:12)\norg.hestiastore.index.datablockfile.DataBlockByteReaderImpl.moveToNextDataBlock(DataBlockByteReaderImpl.java:84)\norg.hestiastore.index.datablockfile.DataBlockByteReaderImpl.optionalyMoveToNextDataBlock(DataBlockByteReaderImpl.java:79)\norg.hestiastore.index.datablockfile.DataBlockByteReaderImpl.readExactly(DataBlockByteReaderImpl.java:71)\norg.hestiastore.index.chunkstore.ChunkData.read(ChunkData.java:85)\norg.hestiastore.index.chunkstore.ChunkStoreReaderImpl.read(ChunkStoreReaderImpl.java:42)\norg.hestiastore.index.chunkstore.ChunkStoreReaderImpl.read(ChunkStoreReaderImpl.java:13)\norg.hestiastore.index.chunkpairfile.ChunkPairFileIterator.moveToNextChunk(ChunkPairFileIterator.java:81)\norg.hestiastore.index.chunkpairfile.ChunkPairFileIterator.&lt;init&gt;(ChunkPairFileIterator.java:42)\norg.hestiastore.index.chunkpairfile.ChunkPairFile.openIteratorAtPosition(ChunkPairFile.java:42)\norg.hestiastore.index.segment.SegmentIndexSearcher.search(SegmentIndexSearcher.java:43)\norg.hestiastore.index.segment.SegmentSearcher.get(SegmentSearcher.java:62)\norg.hestiastore.index.segment.SegmentImpl.get(SegmentImpl.java:166)\norg.hestiastore.index.sst.SstIndexImpl.get(SstIndexImpl.java:163)\norg.hestiastore.index.sst.IndexContextLoggingAdapter.get(IndexContextLoggingAdapter.java:46)\ncom.coroptis.counting.CommandCount.lambda$countBoard$0(CommandCount.java:102)\ncom.coroptis.counting.CommandCount$$Lambda.0x000000080023f0b0.accept()\njava.util.ArrayList.forEach(ArrayList.java:1596)\ncom.coroptis.counting.CommandCount.countBoard(CommandCount.java:99)\ncom.coroptis.counting.CommandCount.lambda$computeNewStates$0(CommandCount.java:82)\ncom.coroptis.counting.CommandCount$$Lambda.0x000000080023e3c0.accept()\njava.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\njava.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\norg.hestiastore.index.sst.PairIteratorToSpliterator.tryAdvance(PairIteratorToSpliterator.java:31)\njava.util.Spliterator.forEachRemaining(Spliterator.java:332)\njava.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\njava.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\njava.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\njava.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\njava.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\njava.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)\ncom.coroptis.counting.CommandCount.computeNewStates(CommandCount.java:81)\ncom.coroptis.counting.CommandCount.countRound(CommandCount.java:48)\ncom.coroptis.counting.Main.main(Main.java:132)\n</code></pre>"},{"location":"profiler-stacktrace/#18-closecleanup-cascades","title":"~18%: close/cleanup cascades","text":"<p>Closing nested readers triggers multiple cleaner/finalization steps. Reusing readers or collapsing the close hierarchy could help.</p> <pre><code>java.io.FileDescriptor.close0(Native Method)\njava.io.FileDescriptor.close(FileDescriptor.java:304)\njava.io.FileDescriptor$1.close(FileDescriptor.java:89)\nsun.nio.ch.FileChannelImpl$Closer.run(FileChannelImpl.java:116)\njdk.internal.ref.CleanerImpl$PhantomCleanableRef.performCleanup(CleanerImpl.java:178)\njdk.internal.ref.PhantomCleanable.clean(PhantomCleanable.java:133)\nsun.nio.ch.FileChannelImpl.implCloseChannel(FileChannelImpl.java:210)\njava.nio.channels.spi.AbstractInterruptibleChannel.close(AbstractInterruptibleChannel.java:113)\nsun.nio.ch.ChannelInputStream.close(ChannelInputStream.java:312)\njava.io.BufferedInputStream.close(BufferedInputStream.java:618)\norg.hestiastore.index.directory.FsFileReaderStream.doClose(FsFileReaderStream.java:33)\norg.hestiastore.index.AbstractCloseableResource.close(AbstractCloseableResource.java:23)\norg.hestiastore.index.datablockfile.DataBlockReaderImpl.doClose(DataBlockReaderImpl.java:29)\norg.hestiastore.index.AbstractCloseableResource.close(AbstractCloseableResource.java:23)\norg.hestiastore.index.datablockfile.DataBlockByteReaderImpl.doClose(DataBlockByteReaderImpl.java:48)\norg.hestiastore.index.AbstractCloseableResource.close(AbstractCloseableResource.java:23)\norg.hestiastore.index.chunkstore.ChunkStoreReaderImpl.doClose(ChunkStoreReaderImpl.java:36)\norg.hestiastore.index.AbstractCloseableResource.close(AbstractCloseableResource.java:23)\norg.hestiastore.index.chunkpairfile.ChunkPairFileIterator.doClose(ChunkPairFileIterator.java:96)\norg.hestiastore.index.AbstractCloseableResource.close(AbstractCloseableResource.java:23)\norg.hestiastore.index.segment.SegmentIndexSearcher.search(SegmentIndexSearcher.java:59)\norg.hestiastore.index.segment.SegmentSearcher.get(SegmentSearcher.java:62)\norg.hestiastore.index.segment.SegmentImpl.get(SegmentImpl.java:166)\norg.hestiastore.index.sst.SstIndexImpl.get(SstIndexImpl.java:163)\norg.hestiastore.index.sst.IndexContextLoggingAdapter.get(IndexContextLoggingAdapter.java:46)\ncom.coroptis.counting.CommandCount.lambda$countBoard$0(CommandCount.java:102)\ncom.coroptis.counting.CommandCount$$Lambda.0x000000080023f0b0.accept()\njava.util.ArrayList.forEach(ArrayList.java:1596)\ncom.coroptis.counting.CommandCount.countBoard(CommandCount.java:99)\ncom.coroptis.counting.CommandCount.lambda$computeNewStates$0(CommandCount.java:82)\ncom.coroptis.counting.CommandCount$$Lambda.0x000000080023e3c0.accept()\njava.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\njava.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:197)\norg.hestiastore.index.sst.PairIteratorToSpliterator.tryAdvance(PairIteratorToSpliterator.java:31)\njava.util.Spliterator.forEachRemaining(Spliterator.java:332)\njava.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:509)\njava.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:499)\njava.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)\njava.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)\njava.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\njava.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:596)\ncom.coroptis.counting.CommandCount.computeNewStates(CommandCount.java:81)\ncom.coroptis.counting.CommandCount.countRound(CommandCount.java:48)\ncom.coroptis.counting.Main.main(Main.java:132)\n</code></pre>"},{"location":"profiler-stacktrace/#what-to-improve-next-actionable","title":"\ud83d\udee0\ufe0f What to improve next (actionable)","text":"<ul> <li>Reduce copies in the read path<ul> <li>Pool and reuse byte buffers across <code>ChunkStoreReader</code>/<code>ChunkPairFileIterator</code>.</li> <li>Where feasible, write directly into the final consumer\u2019s buffer instead of staging arrays.</li> </ul> </li> <li>Fewer, larger IO operations<ul> <li>Increase internal buffer sizes; align chunk/page boundaries to reduce partial reads.</li> <li>Consider a shared channel with a single buffering layer to avoid stacking multiple <code>BufferedInputStream</code>s.</li> </ul> </li> <li>Tame cleanup overhead<ul> <li>Scope readers over a batch of gets to amortize <code>close()</code> and cleaner activity.</li> <li>Ensure try-with-resources closes only once at the highest level; avoid redundant closes in nested layers.</li> </ul> </li> <li>Cut file-open churn<ul> <li>Cache open channels per data file with reference counting; close when idle for a period.</li> <li>If feasible, pre-open frequently accessed files at segment initialization.</li> </ul> </li> </ul> <p>These changes should collectively reclaim the majority of the observed CPU time in this profile.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/arch-index/","title":"Architecture","text":"<p>Here is described basic index concepts. This page explain you how to correctly configure index.</p> <p></p>"},{"location":"architecture/arch-index/#operation-consistency","title":"Operation consistency","text":"<p>The <code>getStream()</code> method can sometimes return inconsistent results, occasionally omitting some items. This can occur in the following scenarios:</p> <ul> <li>Segment Compaction: If data is being streamed from a segment and new keys are added to that segment during the process, the segment may stop providing additional keys. In this case, the stream operation will either continue with the next segment or terminate if no more segments are available.</li> <li>Adding New Keys: If a completely new key is added to the index and is only present in the main index cache, it will not be returned.</li> </ul> <p>To prevent these issues, you should call <code>compact()</code> before invoking <code>getStream()</code> and ensure no new keys are added during streaming.</p> <p>Updating values in the index using <code>put()</code> or deleting keys using <code>delete()</code> does not cause inconsistencies. Updated values will be returned, and deleted keys will be excluded from the stream.</p> <p>Other operations, like <code>get()</code>, remain consistently reliable.</p>"},{"location":"architecture/arch-index/#states","title":"States","text":"<p>Index could be in following states:</p> <p></p> <p></p> <p>Interruption of process of writing data to index could lead to corruption of entire index.</p>"},{"location":"architecture/datablock/","title":"Data Block and Chunk Design in HestiaStore","text":"<p>This document describes the structure and purpose of <code>Block</code> and <code>Chunk</code> objects in the HestiaStore storage engine.</p> <p></p>"},{"location":"architecture/datablock/#block","title":"Block","text":"<p>A Block is the lowest-level physical unit of storage. It has a fixed size (typically a multiple of 4KB) and is directly written to disk.</p>"},{"location":"architecture/datablock/#key-characteristics","title":"Key Characteristics:","text":"<ul> <li>Fixed Size: Determined by <code>BlockFile#getBlockSize()</code>.</li> <li>Header: Each block includes a header with metadata (e.g. magic number, CRC32 checksum, data length).</li> <li>Payload: The remaining portion of the block contains user data (<code>getPayloadSize()</code> returns the usable size).</li> </ul>"},{"location":"architecture/datablock/#block-header-format","title":"Block Header Format:","text":"Offset Size Field Description 0 4 B <code>magic</code> Identifier for block integrity check 4 4 B <code>crc32</code> CRC checksum for payload verification 8 4 B <code>dataLength</code> Actual size of data in the block 12+ N/A <code>payload</code> User data payload <p>Blocks are stored and retrieved via the <code>BlockFile</code> abstraction.</p>"},{"location":"architecture/datablock/#chunk","title":"Chunk","text":"<p>A Chunk represents a variable-sized, logical data unit stored inside a block. It is used to store optionally compressed sets of key-value pairs.</p>"},{"location":"architecture/datablock/#key-characteristics_1","title":"Key Characteristics:","text":"<ul> <li>Variable Size: Can be smaller or span multiple blocks depending on compression.</li> <li>Stored Inside Blocks: Uses the <code>BlockFile</code> to persist data.</li> <li>Compressible: Designed for efficient compression and decompression.</li> <li>Encapsulated Metadata: Chunks also have a header to ensure validity and interpretability.</li> </ul>"},{"location":"architecture/datablock/#chunk-header-format","title":"Chunk Header Format:","text":"Offset Size Field Description 0 4 B <code>magic</code> Chunk type signature 4 4 B <code>crc32</code> CRC of compressed payload 8 4 B <code>compressedLength</code> Length of compressed data 12 4 B <code>uncompressedLength</code> Length of original (uncompressed) data 16+ N/A <code>payload</code> Compressed chunk data <p>Chunks are managed through the <code>ChunkFileStore</code> and written using <code>ChunkWriter</code>.</p>"},{"location":"architecture/datablock/#relationships","title":"Relationships","text":"<ul> <li><code>BlockFile</code> provides the persistent storage mechanism.</li> <li><code>ChunkFileStore</code> maps chunk positions to blocks and provides higher-level access.</li> <li>CRC validation is used in both blocks and chunks to ensure data consistency and detect corruption.</li> </ul>"},{"location":"architecture/segment/","title":"Segment implementation","text":"<p>Segment is core part of index. It represents one string sorted table file with:</p> <ul> <li>Partial consistency - iterator stop working or return consistent data</li> <li>Support Writing changes into delta files</li> <li>Bloom filter for faster evaluating if key is in index</li> <li>Scarce index for faster searching for data in main index</li> </ul>"},{"location":"architecture/segment/#segment-putget-and-iterate-consistency","title":"Segment put/get and iterate consistency","text":"<p>operations like write and get should be always consistent. What is written is read. Iteration behave differently. better than provide old data it stop providing any data.</p> <p>Let's have a followin key value pairs in main index:</p> <pre><code>&lt;a, 20 &gt;\n&lt;b, 30 &gt;\n&lt;c, 40 &gt;\n</code></pre> <p>In segment cache are following pairs:</p> <pre><code>&lt;a, 25&gt;\n&lt;e, 28&gt;\n&lt;b, tombstone&gt;\n</code></pre> <p>When user will iterate throught segment data, there will be followin cases:</p>"},{"location":"architecture/segment/#case-1-read-data","title":"Case 1 - Read data","text":"<pre><code>iterator.read() --&gt; &lt;a, 25&gt;\niterator.read() --&gt; &lt;c, 40&gt;\niterator.read() --&gt; &lt;e, 28&gt;\n</code></pre>"},{"location":"architecture/segment/#case-2-change-data","title":"Case 2 - Change data","text":"<pre><code>iterator.read() --&gt; &lt;a, 25&gt;\nsegment.write(c, 10)\niterator.read() --&gt; null\n</code></pre> <p>Any segment write operation will break segment iterator. It's easier way to secure segment consistency.  </p>"},{"location":"architecture/segment/#caching-of-segment-data","title":"Caching of segment data","text":"<p>In segment following object are cached:</p> <ul> <li>SegmentDeltaCache - contains changed key value pair from segment</li> <li>BloomFilter - bloom filter data</li> <li>ScarceIndex - scarce index data</li> </ul> <p>There are few classes that provide lazy loading of segment data a flexibility to cache segment data. Segment data are managed by following classes: </p> <p></p> <p>Object <code>SegmentData</code> could contains objects <code>SegmentDeltaCache</code>, <code>BloomFilter</code> and <code>ScarceIndex</code>. All of them are lazy loaded by <code>SegmentDataSupplier</code>. For closer class description look at source code.</p> <p>The following image shows that <code>SegmentDatafactory</code> can be referenced from <code>SegmentDataProviderSimple</code>, which is the simplest implementation that merely holds segment data from the factory. The class <code>SegmentDataProviderFromMainCache</code> interacts with the main index cache where the segment data is stored. Data may be evicted from the cache without any notification.</p> <p></p>"},{"location":"architecture/segment/#writing-to-segment","title":"Writing to segment","text":"<p>Opening segment writer immediatelly close all segment readers. When writing operation add key that is in index but is not in cache this value will not returned updated. </p> <p>Putting new pair into segment is here:</p> <p></p>"},{"location":"configuration/","title":"Configuration","text":"<p>Don\u2019t be afraid to experiment\u2014if a configuration is missing or invalid, the Index will fail fast, helping you catch issues early.</p> <p>The index is configured using the <code>IndexConfiguration</code> class. All essential index properties are configurable through the builder. See the example below:</p> <pre><code>IndexConfiguration&lt;Integer, Integer&gt; conf = IndexConfiguration\n    .&lt;Integer, Integer&gt;builder()//\n    .withKeyClass(Integer.class)//\n    .withValueClass(Integer.class)//\n    .withKeyTypeDescriptor(tdi) //\n    .withValueTypeDescriptor(tdi) //\n    .withMaxNumberOfKeysInSegment(4) //\n    .withMaxNumberOfKeysInSegmentCache(10L) //\n    .withMaxNumberOfKeysInSegmentCacheDuringFlushing(12L)//\n    .withMaxNumberOfKeysInSegmentIndexPage(2) //\n    .withMaxNumberOfKeysInCache(3) //\n    .withBloomFilterIndexSizeInBytes(0) //\n    .withBloomFilterNumberOfHashFunctions(4) //\n    .withLogEnabled(false) //\n    .withName(\"test_index\") //\n    .build();\n\nIndex&lt;Integer, Integer&gt; index = Index.&lt;Integer, Integer&gt;create(directory, conf);\n</code></pre> <p>Now let's look at particular parameters.</p>"},{"location":"configuration/#index-directory","title":"Index Directory","text":"<p>Place where all data are stored. There are two already prepared types:</p>"},{"location":"configuration/#in-memory","title":"In Memory","text":"<p>All data are stored in memory. It's created like this:</p> <pre><code>Directory directory = new MemDirectory();\n</code></pre> <p>It's usefull for testing purposes.</p>"},{"location":"configuration/#file-system","title":"File system","text":"<p>Its main purpose is to store index data in the file system. Create a file-system-based directory like this:</p> <pre><code>Directory directory = new FsDirectory(new File('my directory'));\n</code></pre>"},{"location":"configuration/#properties-of-indexconfiguration-class","title":"Properties of <code>IndexConfiguration</code> class","text":"<p>All properties are required and have the following meanings:</p>"},{"location":"configuration/#index-related-configuration","title":"Index related configuration","text":""},{"location":"configuration/#key-class-withkeyclass","title":"Key class - <code>withKeyClass()</code>","text":"<p>A <code>Class</code> object that represents the type of keys used in the index. Only instances of this class may be inserted. While any Java class is technically supported, it's recommended to use simple, compact types for performance reasons. Predefined classes are:</p> <ul> <li>Integer</li> <li>Long</li> <li>String</li> <li>Byte</li> </ul> <p>If a different class is used, the key type descriptor must be set using the <code>withKeyTypeDescriptor()</code> method from the builder. If you use a custom class, you must implement the <code>com.hestiastore.index.datatype.TypeDescriptor</code> interface to describe how the type is serialized and compared.</p>"},{"location":"configuration/#value-class-withvalueclass","title":"Value class - <code>withValueClass()</code>","text":"<p>Required. Specifies the Java class used for values. The same rules that apply to the key class also apply to the value class.</p>"},{"location":"configuration/#index-name-withname","title":"Index name - <code>withName()</code>","text":"<p>Required. Assigns a logical name to the index. This can be useful in diagnostics and logging.</p>"},{"location":"configuration/#key-type-descriptor-withkeytypedescriptor","title":"Key type descriptor - <code>withKeyTypeDescriptor()</code>","text":"<p>Type descriptor for the key class. Required for non-default types.</p>"},{"location":"configuration/#value-type-descriptor-withvaluetypedescriptor","title":"Value type descriptor - <code>withValueTypeDescriptor()</code>","text":"<p>Type descriptor for the value class. Required for non-default types.</p>"},{"location":"configuration/#max-number-of-keys-in-cache-withmaxnumberofkeysincache","title":"Max number of keys in cache - <code>withMaxNumberOfKeysInCache()</code>","text":"<p>Sets the maximum number of key-value pairs allowed in the in-memory cache before flushing.</p>"},{"location":"configuration/#max-number-of-segments-in-cache-withmaxnumberofsegmentsincache","title":"Max number of segments in cache - <code>withMaxNumberOfSegmentsInCache()</code>","text":"<p>Limits the number of segments stored in memory. Useful for controlling memory usage.</p>"},{"location":"configuration/#thread-safe-withthreadsafe","title":"Thread safe - <code>withThreadSafe()</code>","text":"<p>Whether the index instance is safe for concurrent access by multiple threads. When it's set to <code>code</code> true than index will be synchronized between threads.</p>"},{"location":"configuration/#log-enabled-withlogenabled","title":"Log enabled - <code>withLogEnabled()</code>","text":"<p>Enables or disables write-ahead logging. Currently it's experimental feature.</p>"},{"location":"configuration/#segment-related-configuration","title":"Segment related configuration","text":""},{"location":"configuration/#max-number-of-keys-in-segment-withmaxnumberofkeysinsegment","title":"Max number of keys in segment - <code>withMaxNumberOfKeysInSegment()</code>","text":"<p>Sets the maximum number of keys allowed in a single segment. Exceeding this splits the segment.</p>"},{"location":"configuration/#max-number-of-keys-in-segment-cache-withmaxnumberofkeysinsegmentcache","title":"Max number of keys in segment cache - <code>withMaxNumberOfKeysInSegmentCache()</code>","text":"<p>Defines how many keys can be cached from a segment during regular operation.</p>"},{"location":"configuration/#max-number-of-keys-in-segment-cache-during-flushing-withmaxnumberofkeysinsegmentcacheduringflushing","title":"Max number of keys in segment cache during flushing - <code>withMaxNumberOfKeysInSegmentCacheDuringFlushing()</code>","text":"<p>Specifies the maximum number of keys that can be temporarily cached from a segment during flushing.</p>"},{"location":"configuration/#max-number-of-keys-in-segment-index-page-withmaxnumberofkeysinsegmentindexpage","title":"Max number of keys in segment index page - <code>withMaxNumberOfKeysInSegmentIndexPage()</code>","text":"<p>Defines the number of keys in the index page for a segment. This impacts lookup efficiency.</p>"},{"location":"configuration/#bloom-filter-configuration","title":"Bloom filter configuration","text":"<p>A Bloom filter is a probabilistic data structure that efficiently tests whether an element is part of a set. You can find a detailed explanation on Wikipedia. In this context, each segment has its own Bloom filter.</p> <p>To disable bloom filter completle set:</p> <pre><code> .withBloomFilterIndexSizeInBytes(0)\n</code></pre> <p>The settings for the Bloom filter can be adjusted using the following methods:</p>"},{"location":"configuration/#bloom-filter-size-withbloomfilterindexsizeinbytes","title":"Bloom filter size - <code>withBloomFilterIndexSizeInBytes()</code>","text":"<p>Sets the size of the Bloom filter in bytes. A value of 0 disables the use of the Bloom filter.</p>"},{"location":"configuration/#number-of-hash-functions-withbloomfilternumberofhashfunctions","title":"Number of hash functions - <code>withBloomFilterNumberOfHashFunctions()</code>","text":"<p>Sets the number of hash functions used in the Bloom filter.</p>"},{"location":"configuration/#probability-of-false-positive-withbloomfilterprobabilityoffalsepositive","title":"Probability of false positive - <code>withBloomFilterProbabilityOfFalsePositive()</code>","text":"<p>Sets the probability of false positives. When <code>get(someKey)</code> is called on a segment, the Bloom filter is checked to determine if the value is not in the segment. It can return <code>true</code>, indicating that the key could be in the segment. If the Bloom filter indicates the key is in the segment but it's not found, that's a false positive. The probability of this occurring is a value between 0 and 1.</p> <p>Usually, it's not necessary to adjust the Bloom filter settings.</p>"},{"location":"configuration/#changing-index-propertise","title":"Changing Index propertise","text":"<p>Some parameters can be redefined when the index is opened.</p> <pre><code>Index&lt;String, String&gt; index = Index.&lt;String, String&gt;open(directory, conf);\n</code></pre> <p>At allows to pass <code>IndexConfiguration</code> object and this way change configuration parameters. Fllowing table shou parameters that can be changed.  </p> Name Meaning Can be changed Applies to indexName Logical name of the index \ud83d\udfe9 index keyClass Key class \ud83d\udfe5 index valueClass Value class \ud83d\udfe5 index keyTypeDescriptor Key class type descriptor \ud83d\udfe5 index valueTypeDescriptor Value class type descriptor \ud83d\udfe5 index maxNumberOfKeysInSegmentIndexPage Maximum keys in segment index page \ud83d\udfe5 segment maxNumberOfKeysInSegmentCache Maximum number of keys in segment cache \ud83d\udfe9 segment maxNumberOfKeysInSegmentCacheDuringFlushing Maximum keys in cache during flushing \ud83d\udfe9 segment maxNumberOfKeysInCache Maximum keys in the index cache \ud83d\udfe9 index maxNumberOfKeysInSegment Maximum keys in a segment \ud83d\udfe5 segment maxNumberOfSegmentsInCache Maximum number of segments in cache \ud83d\udfe9 index bloomFilterNumberOfHashFunctions Bloom filter - number of hash functions used \ud83d\udfe5 segment bloom filter bloomFilterIndexSizeInBytes Bloom filter - index size in bytes \ud83d\udfe5 segment bloom filter bloomFilterProbabilityOfFalsePositive Bloom filter - probability of false positives \ud83d\udfe5 segment bloom filter diskIoBufferSize Size of the disk I/O buffer \ud83d\udfe9 Disk IO threadSafe If index is thread-safe \ud83d\udfe9 index logEnabled If full logging is enabled \ud83d\udfe9 index"},{"location":"configuration/#add-custom-data-type","title":"Add custom data type","text":"<p>HestiaStore have to know how to work with new data type. So first is create implementatio of <code>com.hestiastore.index.datatype.TypeDescriptor</code>. Than during index creation set let index know about your implementation by <code>withKeyTypeDescriptor</code>. And it's done.</p>"},{"location":"configuration/data-types/","title":"Data types","text":"<p>HestiaStore supports a variety of data types for storing keys and values in a binary-efficient and consistent manner. Each data type is associated with a <code>TypeDescriptor</code>, which handles serialization, deserialization, comparison, and hashing logic.</p> <p>Below is a list of the supported data types and their characteristics.</p> Java Class TypeDescriptor Class Max Length (Bytes) Notes <code>java.lang.Byte</code> <code>TypeDescriptorByte</code> 1 Two's complement representation <code>java.lang.Integer</code> <code>TypeDescriptorInteger</code> 4 Big-endian encoding <code>java.lang.Long</code> <code>TypeDescriptorLong</code> 8 Big-endian encoding <code>java.lang.Float</code> <code>TypeDescriptorFloat</code> 4 IEEE 754 format <code>java.lang.Double</code> <code>TypeDescriptorDouble</code> 8 IEEE 754 format <code>java.lang.String</code> <code>TypeDescriptorShortString</code> 128 UTF-8 encoding, prefixed with 1-byte length, it's default string type descriptor <code>java.lang.String</code> <code>TypeDescriptorString</code> 2 GB UTF-8 encoding, prefixed with 4-byte length <code>org.hestiastore.index.datatype.ByteArray</code> <code>TypeDescriptorByteArray</code> n Raw bytes, length determined by actual data <code>org.hestiastore.index.datatype.NullValue</code> <code>TypeDescriptorNullValue</code> 0 Usefulll when value is not needed. Doesn't occupy any space. <code>org.hestiastore.index.datatype.CompositeValue</code> <code>TypeDescriptorCompositeValue</code> n Represents multiple values."},{"location":"configuration/data-types/#custom-data-types","title":"Custom Data Types","text":"<p>HestiaStore allows advanced users to define custom <code>TypeDescriptor</code> implementations for handling specialized serialization strategies or complex types. Main usecases:</p> <ul> <li>Allows to store new data type.</li> <li>Introduce some specific encoding. it could lead to space saving.</li> <li>Limit data to some exact size</li> </ul> <p>To create a new data type:</p> <ol> <li>Implement the <code>TypeDescriptor&lt;T&gt;</code> interface. It's just a collection of simple interfaces which allows store data type to bytes and restore it from byte array</li> <li>Optionallly register it using <code>org.hestiastore.index.sst.DataTypeDescriptorRegistry.addTypeDescriptor(Class, descriptor)</code>.</li> </ol>"},{"location":"configuration/data-types/#how-to-use-new-data-type","title":"How to use new Data Type","text":"<p>During Index configuration new data type descriptor can by directly used:</p> <pre><code>IndexConfiguration&lt;Integer, Integer&gt; conf = IndexConfiguration\n    .&lt;Integer, Integer&gt;builder()//\n    .withKeyClass(Integer.class)//\n    .withValueClass(MySuperDataType.class)//\n        ...\n    .withValueTypeDescriptor(new TypeDescriptorMySuperDataType()) //\n        ...\n    .build();\n\nIndex&lt;Integer, Integer&gt; index = Index.&lt;Integer, Integer&gt;create(directory, conf);\n</code></pre>"},{"location":"configuration/data-types/#notes","title":"Notes","text":"<ul> <li>All numeric types use big-endian byte order for consistent sorting and comparison.</li> <li><code>ByteArray</code> is a wrapper class designed to support <code>equals()</code>, <code>hashCode()</code>, and lexicographic comparison. It can be used for binary blobs or hash digests.</li> </ul>"},{"location":"configuration/logging/","title":"Logging","text":"<p>HestiaStore uses slf4j for internal logging. So you should include your preferred logging library like logback, log4j, or another with a bridge to slf4j. In case you use log4j, look at the example configuration:</p>"},{"location":"configuration/logging/#example-configuration-file-for-log4j","title":"Example configuration File for log4j","text":"<p>Bellow is the example Log4j2 configuration used in HestiaStore:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Configuration status=\"INFO\"&gt;\n  &lt;Appenders&gt;\n\n    &lt;Console name=\"Console\" target=\"SYSTEM_OUT\"&gt;\n      &lt;PatternLayout\n          pattern=\"%style{%d{ISO8601}}{white} %highlight{%-5level }[%style{%t}{bright,blue}] %style{%-C{1.mv}}{bright,yellow}: %msg%n%throwable\" /&gt;\n    &lt;/Console&gt;\n\n    &lt;Console name=\"indexAppender\" target=\"SYSTEM_OUT\"&gt;\n      &lt;PatternLayout\n          pattern=\"%style{%d{ISO8601}}{white} %highlight{%-5level }[%style{%t}{bright,blue}] index='%style{%X{index.name}}{magenta}' %style{%-C{1.mv}}{bright,yellow}: %msg%n%throwable\" /&gt;\n    &lt;/Console&gt;\n\n  &lt;/Appenders&gt;\n  &lt;Loggers&gt;\n    &lt;logger name=\"org.hestiastore.index\" level=\"DEBUG\" additivity=\"false\"&gt;\n      &lt;appender-ref ref=\"indexAppender\" /&gt;\n    &lt;/logger&gt;\n    &lt;Root level=\"DEBUG\"&gt;\n      &lt;AppenderRef ref=\"Console\"/&gt;\n    &lt;/Root&gt;\n  &lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre> <p>this example will produce logs look like this:</p> <p></p>"},{"location":"configuration/logging/#log-appenders","title":"Log Appenders","text":"<ul> <li>Console (default): Used by all components not explicitly assigned a logger. Outputs time, level, thread, and class name.</li> <li>indexAppender: Specifically configured for <code>org.hestiastore.index</code>, outputs additional context (<code>index.name</code>) for disambiguating messages from different index instances.</li> </ul>"},{"location":"configuration/logging/#customizing-logging-levels","title":"Customizing Logging Levels","text":"<p>You can control verbosity by modifying the <code>&lt;logger&gt;</code> or <code>&lt;Root&gt;</code> levels:</p> <ul> <li><code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code>, or <code>TRACE</code></li> <li>For example, to suppress general debug logs:</li> </ul> <pre><code>&lt;Root level=\"INFO\"&gt;\n</code></pre>"},{"location":"configuration/logging/#disabling-index-logs","title":"Disabling Index Logs","text":"<p>If you want to disable index-specific logging entirely, remove or comment out the <code>org.hestiastore.index</code> logger section. Alternatively log level for package could be set to \"ERROR\".</p>"},{"location":"configuration/logging/#recommendations","title":"Recommendations","text":"<ul> <li>Use <code>DEBUG</code> during development or troubleshooting.</li> <li>Switch to <code>INFO</code> or <code>WARN</code> in production to reduce log noise.</li> <li>Ensure you clear MDC values (<code>ThreadContext.clearAll()</code>) in thread pools to prevent memory leaks or incorrect context reuse.</li> </ul>"},{"location":"configuration/logging/#logging-implementation","title":"Logging Implementation","text":"<p>The <code>indexAppender</code> uses a mapped diagnostic context (MDC) value <code>index.name</code>, which should be set programmatically:</p> <pre><code>ThreadContext.put(\"index.name\", \"userIndex\");\n</code></pre> <p>This allows the log output to include which index instance the message is referring to, aiding in debugging concurrent access or behavior across multiple indexes.</p>"},{"location":"development/","title":"Development","text":"<p>Here are some development related topiscs.</p>"},{"location":"development/documentation/","title":"Documentation","text":"<p>Documentation is available in the following locations:</p> <ul> <li><code>mvn site</code> - Includes detailed project reports from PMC, checkstyle, JUnit test line coverage, and Javadocs. It's not published.</li> <li>GitHub project - Simple technical development oriented site</li> <li>HestiaStore.org site - Detailed, user-focused information</li> </ul> <p>Following text is about HestiaStore.org site documentation.</p>"},{"location":"development/documentation/#how-to-make-changes-to-hestiastoreorg","title":"How to make changes to HestiaStore.org","text":"<p>HestiaStore.org site documentation is served from the main project branch <code>gh-pages</code>. Publishing a new site version involves generating HTML from Markdown and pushing it to <code>gh-pages</code>.</p> <p>Prerequisites:</p> <ul> <li>Installed git</li> <li>Site generating tool mkdocs-material - as described at https://squidfunk.github.io/mkdocs-material/. It is user-friendly and easy to work with. In case of MacOS install it with:</li> </ul> <p><pre><code>brew install mkdocs-material\n</code></pre> * Some Markdown editor of your choice * GitHub personal access token with permission to read and write project pages.</p>"},{"location":"development/documentation/#page-editing-and-viewing-documentation-locally","title":"Page editing and viewing documentation locally","text":"<p>From project checkout branch <code>docs</code>, there are all source files for main site. Markdown files for documentation are located in the directory <code>docs</code>. To preview documentation changes locally, run:</p> <pre><code>mkdocs serve\n</code></pre> <p>Now at http://127.0.0.1:8080/HestiaStore/ should display the documentation.</p> <p>The <code>mkdocs.yml</code> file in the root directory controls site structure, navigation, and theme. For more information see mkdocs-material documentation.</p>"},{"location":"development/documentation/#how-to-publish-changes-at-hestiastoreorg","title":"How to publish changes at hestiastore.org","text":"<ul> <li>From github.com/jajir/HestiaStore checkout branch <code>docs</code>. </li> <li>Make changes</li> <li>Commit changes to <code>docs</code></li> <li>Pull again to be sure, that latest chnages from branch <code>gh-pages</code> is at local.</li> <li>Then, run the following command locally:</li> </ul> <p><pre><code>mkdocs gh-deploy\n</code></pre>   In a few minutes (could be 15 minutes) new documentation will be published.</p>"},{"location":"development/guides/","title":"Development","text":"<p>Here are some development related topiscs.</p>"},{"location":"development/guides/#how-to-run-jmh-benchmarks","title":"How to run JMH benchmarks","text":"<p>Follow this steps: * Compile whole project and create pacakge containing all benchmarks data * Go to <code>jmh-benchmarks</code> * Execute it, with temp directory in <code>target</code> directory</p> <pre><code>mvn clean install\ncd jmh-benchmarks\njava -Ddir=./target/ -jar target/jmh-benchmarks.jar\n</code></pre> <p>Specific JMH benchmark class could be run:</p> <pre><code>java -Ddir=./target/ -jar target/jmh-benchmarks.jar SegmentSearchBenchmark\n</code></pre> <p>result could look like:</p> <pre><code>Benchmark                                             Mode  Cnt    Score      Error  Units\nSequentialFileReadingBenchmark.test_with_buffer_01KB  avgt    4   70.747 \u00b1   42.480  ms/op\nSequentialFileReadingBenchmark.test_with_buffer_02KB  avgt    4   60.009 \u00b1   52.899  ms/op\nSequentialFileReadingBenchmark.test_with_buffer_04KB  avgt    4   51.254 \u00b1   30.112  ms/op\nSequentialFileReadingBenchmark.test_with_buffer_08KB  avgt    4   48.600 \u00b1   28.892  ms/op\nSequentialFileReadingBenchmark.test_with_buffer_16KB  avgt    4   48.471 \u00b1   25.665  ms/op\nSequentialFileReadingBenchmark.test_with_buffer_32KB  avgt    4   45.256 \u00b1   24.986  ms/op\nSequentialFileReadingBenchmark.test_with_buffer_64KB  avgt    4   45.204 \u00b1   24.867  ms/op\nSequentialFileWritingBenchmark.test_with_buffer_01KB  avgt    4  238.075 \u00b1   75.311  ms/op\nSequentialFileWritingBenchmark.test_with_buffer_02KB  avgt    4  271.272 \u00b1   64.747  ms/op\nSequentialFileWritingBenchmark.test_with_buffer_04KB  avgt    4  276.001 \u00b1   45.815  ms/op\nSequentialFileWritingBenchmark.test_with_buffer_08KB  avgt    4  352.189 \u00b1 1140.814  ms/op\nSequentialFileWritingBenchmark.test_with_buffer_16KB  avgt    4  258.806 \u00b1   44.693  ms/op\nSequentialFileWritingBenchmark.test_with_buffer_32KB  avgt    4  276.246 \u00b1  135.019  ms/op\nSequentialFileWritingBenchmark.test_with_buffer_64KB  avgt    4  275.944 \u00b1  128.835  ms/op\n</code></pre> <p>When some JMH benchmark class is changed command <code>mvn package</code> have to be run.</p>"},{"location":"development/guides/#possible-problems","title":"Possible problems","text":"<p>Generally JMH is quite fragile. Small changes broke JMH benchmark execution. Usually helps rebuild project and start again as described above.</p>"},{"location":"development/guides/#load-test","title":"Load test","text":"<p>Runnign JVM should be inspected with some profiller. For profilling is usefull to hae long running task to watch it. Go to project <code>load-test</code>. Following command show all optional parameters:</p> <pre><code>java -jar target/load-test.jar com.coroptis.index.loadtest.Main --help\n</code></pre> <p>Theer are two main supported operations. First is data generating. It's could be usefull to place in java profilling agent. It could look like:</p> <pre><code>java \\\n    -agentpath:/Applications/YourKit-Java-Profiler-2023.9.app/Contents/Resources/bin/mac/libyjpagent.dylib=exceptions=disable,delay=10000,listen=all \\\n    -jar target/load-test.jar com.coroptis.index.loadtest.Main \\\n    --write \\\n    --directory /Volumes/LaCie/test/  \\\n    --count 5_000_000_000 \\\n    --max-number-of-keys-in-cache 5_000_000 \\\n    --max-number-of-keys-in-segment 10_000_000 \\\n    --max-number-of-keys-in-segment-cache 500_000 \\\n    --max-number-of-keys-in-segment-cache-during-flushing 2_000_000 \\\n    --max-number-of-keys-in-segment-index-page 1_000 \\\n    --bloom-filter-index-size-in-bytes 10_000_000 \\\n    --bloom-filter-number-of-hash-functions 2\n</code></pre> <p>It will generate 210 GB of testing data. Furst search test can be performed like this:</p> <pre><code>java \\\n    -agentpath:/Applications/YourKit-Java-Profiler-2023.9.app/Contents/Resources/bin/mac/libyjpagent.dylib=exceptions=disable,delay=10000,listen=all \\\n    -jar target/load-test.jar com.coroptis.index.loadtest.Main \\\n    --search \\\n    --directory /Volumes/LaCie/test/  \\\n    --count 5_000_000_000 \\\n    --max-key 5_000_000_000 \\\n    --max-number-of-keys-in-cache 5_000_000 \\\n    --max-number-of-keys-in-segment 10_000_000 \\\n    --max-number-of-keys-in-segment-cache 500_000 \\\n    --max-number-of-keys-in-segment-cache-during-flushing 2_000_000 \\\n    --max-number-of-keys-in-segment-index-page 1_000 \\\n    --bloom-filter-index-size-in-bytes 10_000_000 \\\n    --bloom-filter-number-of-hash-functions 2\n</code></pre>"},{"location":"development/guides/#development_1","title":"Development","text":"<p>Mockito requires reflective access to non-public parts in a Java module. It could be manually open by passing following parameter as jvm parameter:</p> <pre><code>--add-opens=java.base/java.lang=ALL-UNNAMED\n</code></pre>"},{"location":"development/guides/#how-to-get-segment-disk-size","title":"How to get segment disk size","text":"<p>On apple try:</p> <pre><code>diskutil  info /Volumes/LaCie\n</code></pre>"},{"location":"development/release/","title":"\ud83d\ude80 Releasing a New Version","text":"<p>This is a step-by-step guide for making a new HestiaStore release.</p>"},{"location":"development/release/#versioning-of-the-project","title":"\u261d\ufe0f Versioning of the project","text":"<p>The project uses the traditional versioning pattern known as Semantic Versioning, detailed at https://semver.org. The version number consists of three components separated by dots:</p> <pre><code>0.3.6\n</code></pre> <p>Each number has the following meaning:</p> <ul> <li><code>0</code> - Major project version. Project API could be incompatible between two major versions.</li> <li><code>3</code> - Minor project version. Contains changes in features, performance optimizations, and small improvements. Minor versions should be compatible.</li> <li><code>6</code> - Patch version. Bug fixing project release.</li> </ul> <p>There are also snapshot versions with version number <code>0.3.6-SNAPSHOT</code>. Snapshot versions should not be stored in the Maven repository.</p>"},{"location":"development/release/#branching-strategy","title":"\ud83d\udd4a\ufe0f Branching strategy","text":"<p>We use a simplified GitHub Flow:</p> <ul> <li><code>main</code>: the primary development and release branch. Small changes may be committed directly to <code>main</code>, while larger or experimental features must be developed in a separate branch and merged via pull request.</li> <li>Feature branches are created from <code>main</code> for larger or isolated changes. Use descriptive names like <code>feature/compression</code>, <code>fix/index-scan</code>, etc.</li> </ul> <p>The deprecated <code>devel</code> branch has been removed and is no longer used.</p>"},{"location":"development/release/#release-prerequisites","title":"\ud83e\uddd1\u200d\ud83d\udcbb Release prerequisites","text":"<p>The release will be published to Maven Central. Release configuration secrets are placed at the Maven settings file <code>~/.m2/settings.xml</code>. Adjust <code>settings.xml</code> in <code>~/.m2/settings.xml</code> as described in GitHub's official documentation on how to work with the GitHub Maven repository. Generate a valid token and you are done.</p>"},{"location":"development/release/#provide-correct-package-signature","title":"Provide correct package signature","text":"<p>In your <code>~/.m2/settings.xml</code> file, add the following section:</p> <pre><code>&lt;settings&gt;\n    ...\n   &lt;profile&gt;\n     &lt;id&gt;release&lt;/id&gt;\n       &lt;properties&gt;\n       &lt;gpg.executable&gt;gpg&lt;/gpg.executable&gt;\n       &lt;gpg.passphrase&gt;--pgp-password--&lt;/gpg.passphrase&gt;\n     &lt;/properties&gt;      \n   &lt;/profile&gt;\n    ...\n&lt;/settings&gt;\n</code></pre>"},{"location":"development/release/#setup-maven-central-accout-secrets","title":"Setup maven central accout secrets","text":"<p>This provides <code>org.sonatype.central:central-publishing-maven-plugin</code> plugin secrets to enable login to the Maven Central account where release data will be placed. You must have an account with a verified namespace <code>org.hestiastore</code> at central.sonatype.com. From the <code>Account</code> section, generate a key and password. These should be added to:</p> <pre><code>&lt;settings&gt;\n    ...\n    &lt;servers&gt;\n        &lt;server&gt;\n            &lt;id&gt;central&lt;/id&gt;\n           &lt;username&gt;------&lt;/username&gt;\n           &lt;password&gt;---------------token---------------&lt;/password&gt;\n       &lt;/server&gt;\n    &lt;/servers&gt;\n    ...\n&lt;/settings&gt;\n</code></pre>"},{"location":"development/release/#perform-release","title":"Perform release","text":"<p>Perform the following steps to create a new release:</p>"},{"location":"development/release/#1-checkout-the-main-branch","title":"1. \ud83c\udff7\ufe0f Checkout the <code>main</code> branch","text":"<pre><code>git checkout main\n</code></pre>"},{"location":"development/release/#2-set-the-release-version","title":"2. \ud83d\udd22 Set the Release Version","text":"<pre><code>mvn versions:set -DnewVersion=0.0.12\ngit commit -am \"release: version 0.0.12\"\n</code></pre>"},{"location":"development/release/#3-tag-and-push-the-release","title":"3. \ud83c\udff7\ufe0f Tag and Push the Release","text":"<pre><code>git tag v0.0.12\ngit push --follow-tags\n</code></pre>"},{"location":"development/release/#4-deploy-the-release","title":"4. \ud83d\ude80 Deploy the Release","text":"<p>Deploy the release (can be later automated via GitHub Actions or done manually):</p> <pre><code>mvn deploy -P release\n</code></pre>"},{"location":"development/release/#5-bump-to-the-next-snapshot-version","title":"5. \ud83d\udcc8 Bump to the Next Snapshot Version","text":"<pre><code>mvn versions:set -DnewVersion=0.0.13-SNAPSHOT\ngit commit -am \"post-release: bumped to 0.0.13-SNAPSHOT\"\ngit push\n</code></pre>"},{"location":"development/release/#6-publish-the-release-on-github","title":"6. \ud83d\udcdd Publish the Release on GitHub","text":"<ol> <li>Go to https://github.com/jajir/HestiaStore/releases and choose <code>Draft a new release</code>.</li> <li>From the drop-down box <code>target: main</code>, select <code>recent commits</code> and select the correct one with name <code>release: version 0.0.12</code>.</li> <li>From the drop-down box <code>Choose a tag</code> enter <code>release-0.0.12</code> and click <code>Create new tag: release ...</code>. Now in the repo, the tag clearly signals the new release.</li> <li>Release title should be <code>Release 0.0.3</code> and in the <code>Write</code> field, use the text generated from the template below:</li> <li>Press <code>Publish release</code>.</li> </ol> <p>Text template:</p> <pre><code>Release to maven central:\n\n```xml\n&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.hestiastore.index&lt;/groupId&gt;\n    &lt;artifactId&gt;core&lt;/artifactId&gt;\n    &lt;version&gt;0.0.3&lt;/version&gt; &lt;!-- Replace with the actual version --&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;\n```\n</code></pre>"},{"location":"development/release/#7-celebrate","title":"7. \ud83c\udf89 Celebrate","text":"<p>That's it \u2014 the release is live and development can continue.</p>"},{"location":"development/release/#helpful-commands","title":"\ud83e\uddf0 Helpful Commands","text":"<p>At the beginning there may be problems. Here are a few tricks that help to gather more information.</p>"},{"location":"development/release/#how-to-use-a-custom-settingsxml-file","title":"How to Use a Custom settings.xml File","text":"<pre><code>mvn --settings ./src/main/settings.xml clean deploy\n</code></pre>"},{"location":"development/release/#how-to-set-the-maven-project-version","title":"How to Set the Maven Project Version","text":"<pre><code>mvn versions:set -DnewVersion=1.0.1-SNAPSHOT\n</code></pre>"},{"location":"development/release/#check-dependencies","title":"Check dependencies","text":"<p>Try to update dependencies. Check them with:</p> <pre><code>mvn versions:display-dependency-updates\n</code></pre>"},{"location":"how-to-use/","title":"\ud83d\ude80 Getting Started","text":"<p>Note: HestiaStore is a library, not a standalone application. It is designed to be integrated into a larger system to provide efficient storage and retrieval of large volumes of key-value pairs.</p> <p>HestiaStore is a Java library distributed as a JAR file. It can be directly and easily used in any Java application. To get started, first refer to the installation guide and then explore usage examples.</p>"},{"location":"how-to-use/#use-cases","title":"\ud83d\udca1 Use Cases","text":"<p>The library is suitable for scenarios requiring storage of large amounts of key-value pairs. HestiaStore is especially effective when:</p> <ul> <li>Store billions of key-value pairs</li> <li>Cloud storage is not an option</li> <li>You need to search key-value pairs efficiently</li> <li>Values must be persisted to disk</li> </ul> <p>If all key-value pairs can be held in memory, it's usually better and faster to use an in-memory structure like <code>java.util.HashMap</code>. For smaller datasets, a traditional relational database may be more appropriate.</p>"},{"location":"how-to-use/examples/","title":"\ud83d\udcda Examples of HestiaStore Usage","text":""},{"location":"how-to-use/examples/#hello-world-example","title":"\ud83d\udc4b Hello World Example","text":"<pre><code>import com.hestiastore.index.Index;\nimport com.hestiastore.index.IndexFactory;\n\npublic class Example {\n  public static void main(String[] args) {\n        // Create an in-memory file system abstraction\n        final Directory directory = new MemDirectory();\n\n        // Prepare index configuration\n        final IndexConfiguration&lt;String, String&gt; conf = IndexConfiguration\n                .&lt;String, String&gt;builder()//\n                .withKeyClass(String.class)//\n                .withValueClass(String.class)//\n                .withName(\"test_index\") //\n                .build();\n\n        // create new index\n        Index&lt;String, String&gt; index = Index.&lt;String, String&gt;create(directory,\n                conf);\n\n        // Perform basic operations with the index\n        index.put(\"Hello\", \"World\");\n\n        String value = index.get(\"Hello\");\n        System.out.println(\"Value for 'Hello': \" + value);\n\n        index.close();\n  }\n}\n</code></pre> <p>This creates a simple in-memory index and stores a key-value pair.</p> <p>When you have first example you can dive into more advanced configuration. There are explained details about <code>Directory</code> object and using custom Key/Value classes</p>"},{"location":"how-to-use/examples/#using-hestiastore-with-the-file-system","title":"\ud83d\udcbe Using HestiaStore with the File System","text":"<p>This is the most common scenario for storing data on persistent storage. Creating an index in a given directory can be done as follows:</p> <pre><code>Directory directory = System.getProperty(new File(\"./index-directory\"));\n\n// Prepare index configuration\nfinal IndexConfiguration&lt;String, String&gt; conf = IndexConfiguration\n        .&lt;String, String&gt;builder()//\n        .withKeyClass(String.class)//\n        .withValueClass(String.class)//\n        .withName(\"test_index\") //\n        .build();\n\n// create new index\nIndex&lt;String, String&gt; index = Index.&lt;String, String&gt;create(directory,\n        conf);\n</code></pre> <p>This immediately creates the initial index files and makes it ready to use.</p> <p>Note When the index starts working with a directory, it locks it with a <code>.lock</code> file. When the index is closed, the <code>.lock</code> file is removed. This prevents other applications from simultaneously modifying the index data.</p>"},{"location":"how-to-use/examples/#opening-an-existing-index","title":"\ud83d\udcc2 Opening an Existing Index","text":"<p>Please note that Index uses separate methods for creating an index and for opening an already existing index. To open an already existing index, use:</p> <pre><code>IndexConfiguration&lt;String, String&gt; conf = IndexConfiguration\n        .&lt;String, String&gt;builder()//\n        .withKeyClass(String.class)//\n        .withValueClass(String.class)//\n        .withName(\"test_index\") //\n        .build();\n\nIndex&lt;String, String&gt; index = Index.&lt;String, String&gt;open(directory, conf);\n</code></pre>"},{"location":"how-to-use/examples/#data-manipulation","title":"\u270d\ufe0f Data Manipulation","text":"<p>There are two methods <code>put</code> and <code>get</code> using them is straightforward:</p> <pre><code>index.put(\"Hello\", \"World\");\n\nString value = index.get(\"Hello\");\n</code></pre> <p>Stored values are immediately available. Command ordering could be random.</p>"},{"location":"how-to-use/examples/#sequential-data-reading","title":"\ud83d\udcc8 Sequential Data Reading","text":"<p>Reading from index could be done like this:</p> <pre><code>index.getStream(null).forEach(entry -&gt; {\n\n  // Do what have to be done\n    System.out.println(\"Entry: \" + entry);\n\n});\n</code></pre> <p>Data are returned in ascending ordering. This ordering can't be changed. Index stores data in segments. In some cases could be usefull to sequentially read just some segments. Segment could be selected by object <code>SegmentWindow</code></p> <pre><code>SegmentWindow window = SegmentWindow.of(1000, 10);\n\nindex.getStream(window).forEach(entry -&gt; {\n    System.out.println(\"Entry: \" + entry);\n});\n</code></pre>"},{"location":"how-to-use/examples/#data-maintenance","title":"\ud83e\uddf9 Data Maintenance","text":"<p>In some cases could be useful to perform maintenance with data. There are following operations with <code>Index</code>:</p> <ul> <li><code>flush()</code> It flush all data from memory to disk to ensure that all data is safely stored. It make sure that data are stored. Could be called before index iterating and when user want to be sure, that all data are stored.</li> <li><code>checkAndRepairConsistency()</code> It verify that meta data about data in index are consistent. Some problems coudl repair. When index is beyond repair it fails.</li> <li><code>compact();</code> Goes through all segments add compact main segment data with temporal files. It can save disk space.</li> </ul>"},{"location":"how-to-use/examples/#limitations","title":"\u26a0\ufe0f Limitations","text":""},{"location":"how-to-use/examples/#stale-results-from-indexgetstream","title":"\ud83c\udf00 Stale Results from <code>index.getStream()</code>","text":"<p>Data from <code>index.getStream()</code> method could be stale or invalid. It's corner case when next readed key value pair is changed. Index data streaming is splited internally into steps <code>hasNextElement()</code> and <code>getNextElement()</code>. Following example will show why it's no possible to use index cache:</p> <pre><code>index.hasNextElement(); // --&gt; true\n</code></pre> <p>Now next element has to be known to be sure that exists. Let's suppose that in index is just one element <code>&lt;k1,v1&gt;</code>.</p> <pre><code>index.delete(\"k1\");\nindex.nextElement(); // --&gt; fail\n</code></pre> <p>last operation will fail because there is not possible to find next element because <code>&lt;k1,v1&gt;</code> was deleted. To prevent this problem index cache is not used during index streaming. If all index content should be streamed than before streaming should be <code>compact()</code> method and during streaming data shouldn't be changed.</p> <p>To be sure that all data is read than before reading perform <code>Index.flush()</code> and during iterating avoid using of <code>Index.put()</code> and <code>Index.delete()</code> operations.</p>"},{"location":"how-to-use/examples/#thread-safety","title":"\ud83d\udd12 Thread Safety","text":"<p>Note: Index is not thread-safe by default. Use <code>.withThreadSafe(true)</code> in the configuration to enable thread safety.</p>"},{"location":"how-to-use/examples/#exception-handling","title":"\ud83e\udde8 Exception Handling","text":"<p>Here are exceptions that could be throws from HestiaStore:</p> <ul> <li><code>NullPointerException</code> -  When something fails really badly. For example when disk reading fails or when user delete part of configuration file.</li> <li><code>IndexException</code> - Usually indicated internal HestiaStore problem with data consistency.</li> <li><code>IllegalArgumentException</code> - validation error, for example when key type is not specified. It's also thrown when some object is not initialized correctly.</li> <li><code>IllegalStateException</code> - When HestiaStore is in inconsistent state and is unable to recover.</li> </ul> <p>All exceptions are runtime exceptions and doesn't have to be explicitly handled.</p>"},{"location":"how-to-use/install/","title":"Installation Guide","text":""},{"location":"how-to-use/install/#prerequisites","title":"\u2699\ufe0f Prerequisites","text":"<ul> <li>Java 11 or higher</li> <li>Maven 3.6+ or Gradle 6+</li> </ul> <p>HestiaStore is distributed via Maven Central.</p>"},{"location":"how-to-use/install/#maven","title":"\ud83d\udee0\ufe0f Maven","text":"<p>In your <code>pom.xml</code>, add the following to the <code>dependencies</code> section:</p> <pre><code>&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.hestiastore.index&lt;/groupId&gt;\n    &lt;artifactId&gt;core&lt;/artifactId&gt;\n    &lt;version&gt;0.0.5&lt;/version&gt; &lt;!-- Replace with the actual version --&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"how-to-use/install/#optionaly-verify-installation","title":"\u2705 (Optionaly) Verify Installation","text":"<p>To verify that HestiaStore was installed successfully and is accessible from your project, try compiling and running a minimal example or run:</p> <pre><code>mvn dependency:tree\n</code></pre> <p>to confirm the dependency was resolved correctly.</p>"},{"location":"how-to-use/install/#gradle","title":"\ud83d\udee0\ufe0f Gradle","text":"<p>For Gradle, add the following to your <code>build.gradle</code>:</p> <pre><code>dependencies {\n  implementation \"org.hestiastore.index:core:0.0.5\" // Replace with the actual version\n}\n</code></pre>"},{"location":"how-to-use/install/#build-from-sources","title":"\ud83e\uddf1 Build from Sources","text":"<p>Source code for each release can be downloaded from GitHub HestiaStore releases. Then, build the desired version using <code>mvn install</code>.</p>"}]}