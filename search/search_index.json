{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HestiaStore is a lightweight, embeddable key-value storage engine optimized for billions of records, designed to run in a single directory with high performance and minimal configuration. Features: \u2022 Java-based with minimum external dependencies \u2022 Requires Java 17+ \u2022 In-memory or file-backed indexes \u2022 Optional write-ahead logging \u2022 Supports user-defined key/value types \u2022 Optionaly could be thread safe Documentation HestiaStore Index architecture How to use HestiaStore including some examples Index configuration and configuration properties explaining Logging How to setup loggin Project versioning and how to release snapshot and new version Security and related topics Change log How to use HestiaStore Index should be created with builder, which make index instance. For example: // Create an in-memory file system abstraction Directory directory = new MemDirectory(); // Prepare index configuration IndexConfiguration<String, String> conf = IndexConfiguration .<String, String>builder()// .withKeyClass(String.class)// .withValueClass(String.class)// .withName(\"test_index\") // .build(); // create new index Index<String, String> index = Index.<String, String>create(directory, conf); // Do some work with the index index.put(\"Hello\", \"World\"); String value = index.get(\"Hello\"); System.out.println(\"Value for 'Hello': \" + value); Questions If you encounter a bug, have a feature request, or need help using HestiaStore, please create an issue .","title":"Home"},{"location":"#documentation","text":"HestiaStore Index architecture How to use HestiaStore including some examples Index configuration and configuration properties explaining Logging How to setup loggin Project versioning and how to release snapshot and new version Security and related topics Change log","title":"Documentation"},{"location":"#how-to-use-hestiastore","text":"Index should be created with builder, which make index instance. For example: // Create an in-memory file system abstraction Directory directory = new MemDirectory(); // Prepare index configuration IndexConfiguration<String, String> conf = IndexConfiguration .<String, String>builder()// .withKeyClass(String.class)// .withValueClass(String.class)// .withName(\"test_index\") // .build(); // create new index Index<String, String> index = Index.<String, String>create(directory, conf); // Do some work with the index index.put(\"Hello\", \"World\"); String value = index.get(\"Hello\"); System.out.println(\"Value for 'Hello': \" + value);","title":"How to use HestiaStore"},{"location":"#questions","text":"If you encounter a bug, have a feature request, or need help using HestiaStore, please create an issue .","title":"Questions"},{"location":"architecture/","text":"Architecture Here is described basic index concepts. This page explain you how to correctly configure index. Operation consistency The getStream() method can sometimes return inconsistent results, occasionally omitting some items. This can occur in the following scenarios: Segment Compaction: If data is being streamed from a segment and new keys are added to that segment during the process, the segment may stop providing additional keys. In this case, the stream operation will either continue with the next segment or terminate if no more segments are available. Adding New Keys: If a completely new key is added to the index and is only present in the main index cache, it will not be returned. To prevent these issues, you should call compact() before invoking getStream() and ensure no new keys are added during streaming. Updating values in the index using put() or deleting keys using delete() does not cause inconsistencies. Updated values will be returned, and deleted keys will be excluded from the stream. Other operations, like get() , remain consistently reliable. States Index could be in following states: Interruption of process of writing data to index could lead to corruption of entire index.","title":"Architecture"},{"location":"architecture/#architecture","text":"Here is described basic index concepts. This page explain you how to correctly configure index.","title":"Architecture"},{"location":"architecture/#operation-consistency","text":"The getStream() method can sometimes return inconsistent results, occasionally omitting some items. This can occur in the following scenarios: Segment Compaction: If data is being streamed from a segment and new keys are added to that segment during the process, the segment may stop providing additional keys. In this case, the stream operation will either continue with the next segment or terminate if no more segments are available. Adding New Keys: If a completely new key is added to the index and is only present in the main index cache, it will not be returned. To prevent these issues, you should call compact() before invoking getStream() and ensure no new keys are added during streaming. Updating values in the index using put() or deleting keys using delete() does not cause inconsistencies. Updated values will be returned, and deleted keys will be excluded from the stream. Other operations, like get() , remain consistently reliable.","title":"Operation consistency"},{"location":"architecture/#states","text":"Index could be in following states: Interruption of process of writing data to index could lead to corruption of entire index.","title":"States"}]}